<!DOCTYPE html>
<!-- GitViz ‚Äì URL Builder & Editor
* what are you doing here ?
* are you trying to copy my code ? or looking if its ai generated ?
* if you are, you are not gonna find anything here.
* this is a custom code that i wrote for my own use.
* if you want to use it, you can, but you need to ask me for permission.
* if you are not trying to copy my code, or looking if its ai generated, then you can continue.
* i hope you enjoy my code.
* if you have any questions, feel free to ask me.
* if you have any suggestions, feel free to suggest them.
* if you have any bugs, feel free to report them.
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Widget</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Poppins:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Raleway:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Ubuntu:wght@400;700&family=Nunito:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Crimson+Text:wght@400;700&family=Libre+Baskerville:wght@400;700&family=PT+Sans:wght@400;700&family=PT+Serif:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Bebas+Neue&family=Anton&family=Fjalla+One&family=Righteous&family=Bangers&family=Fredoka+One:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&family=Work+Sans:wght@400;700&family=Space+Grotesk:wght@400;700&family=DM+Sans:wght@400;700&family=Manrope:wght@400;700&family=Sora:wght@400;700&family=Outfit:wght@400;700&family=Plus+Jakarta+Sans:wght@400;700&family=Figtree:wght@400;700&family=Geist:wght@400;700&family=JetBrains+Mono:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }

        body {
            font-family: var(--custom-font, Arial, sans-serif);
            color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #spotify-container {
            text-align: center;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        /* Overlay Style: Default (Vinyl style) */
        body.overlay-style-default #spotify-container {
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: flex-start !important;
            position: relative !important;
            overflow: hidden !important;
            min-height: 120px !important;
        }

        body.overlay-style-default .vinyl-container {
            position: relative;
            width: 120px;
            height: 120px;
            flex-shrink: 0;
            z-index: 2;
        }

        body.overlay-style-default .vinyl {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #1a1a1a 30%, #2a2a2a 30%, #2a2a2a 35%, #1a1a1a 35%, #1a1a1a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: rotate 10s linear infinite;
            position: relative;
        }

        body.overlay-style-default .vinyl.playing {
            animation-play-state: running;
        }

        body.overlay-style-default .vinyl.paused {
            animation-play-state: paused;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        body.overlay-style-default .vinyl-image {
            width: 60%;
            height: 60%;
            border-radius: 50%;
            object-fit: cover;
            background: #1a1a1a;
        }

        body.overlay-style-default .vinyl-center {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #000;
            z-index: 3;
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1);
        }

        body.overlay-style-default .track-background {
            position: absolute;
            left: 60px;
            top: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            filter: blur(15px);
            transform: scale(1.2);
            z-index: 0;
            opacity: 0.7;
        }

        body.overlay-style-default .track-background::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.6));
        }

        body.overlay-style-default .spotify-track {
            position: relative;
            z-index: 1;
            padding: 20px 30px 20px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            min-width: 300px;
            text-align: left;
        }

        body.overlay-style-default .track-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }

        body.overlay-style-default .track-name {
            font-weight: bold;
            font-size: var(--font-size-main, 24px);
            color: #ffffff;
            text-shadow:
                0 0 10px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(0, 0, 0, 0.6),
                2px 2px 4px rgba(0, 0, 0, 0.9),
                -1px -1px 2px rgba(255, 255, 255, 0.1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        body.overlay-style-default .track-artist {
            font-size: calc(var(--font-size-main, 24px) * 0.85);
            color: rgba(255, 255, 255, 0.9);
            text-shadow:
                0 0 10px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(0, 0, 0, 0.6),
                2px 2px 4px rgba(0, 0, 0, 0.9),
                -1px -1px 2px rgba(255, 255, 255, 0.1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        body.overlay-style-default .spotify-icon {
            display: none;
        }

        body.overlay-style-default .track-separator {
            display: none;
        }

        /* Overlay Style: Card */
        body.overlay-style-card #spotify-container {
            background: rgba(0, 0, 0, 0.6) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-radius: 12px !important;
            padding: 16px 20px !important;
            backdrop-filter: blur(10px) !important;
            display: inline-block !important;
            min-width: fit-content !important;
        }

        /* Overlay Style: Bubble */
        body.overlay-style-bubble #spotify-container {
            background: linear-gradient(135deg, rgba(29, 185, 84, 0.2), rgba(30, 215, 96, 0.2)) !important;
            border: 2px solid rgba(29, 185, 84, 0.3) !important;
            border-radius: 24px !important;
            padding: 18px 24px !important;
            backdrop-filter: blur(10px) !important;
            display: inline-block !important;
            min-width: fit-content !important;
        }

        /* Overlay Style: Minimal */
        body.overlay-style-minimal #spotify-container {
            background: rgba(255, 255, 255, 0.05) !important;
            border-left: 3px solid rgba(29, 185, 84, 0.5) !important;
            border-top: none !important;
            border-right: none !important;
            border-bottom: none !important;
            border-radius: 0 !important;
            padding: 14px 20px !important;
            display: inline-block !important;
            min-width: fit-content !important;
        }

        /* Overlay Style: Gradient */
        body.overlay-style-gradient #spotify-container {
            background: linear-gradient(90deg, rgba(29, 185, 84, 0.15), rgba(30, 215, 96, 0.15)) !important;
            border: 1px solid rgba(29, 185, 84, 0.3) !important;
            border-radius: 16px !important;
            padding: 16px 22px !important;
            box-shadow: 0 2px 8px rgba(29, 185, 84, 0.1) !important;
            display: inline-block !important;
            min-width: fit-content !important;
        }

        /* Overlay Style: Glass */
        body.overlay-style-glass #spotify-container {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 20px !important;
            padding: 18px 24px !important;
            backdrop-filter: blur(20px) saturate(180%) !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2) !important;
            display: inline-block !important;
            min-width: fit-content !important;
        }

        .spotify-track {
            font-size: var(--font-size-main, 24px);
            font-weight: bold;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .spotify-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .track-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .track-name {
            font-weight: bold;
        }

        .track-separator {
            opacity: 0.7;
        }

        .track-artist {
            opacity: 0.9;
        }

        .error-message {
            color: #ff6b6b;
            font-size: var(--font-size-main, 24px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .no-track {
            color: #888;
            font-size: var(--font-size-main, 24px);
            font-style: italic;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .spotify-connect-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px 32px;
            background: #1DB954;
            color: #ffffff;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(29, 185, 84, 0.3);
        }

        .spotify-connect-button:hover {
            background: #1ed760;
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(29, 185, 84, 0.4);
        }

        .spotify-connect-button:active {
            transform: scale(0.98);
        }

        .spotify-connect-button svg {
            width: 24px;
            height: 24px;
        }

        .connect-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 40px 20px;
            text-align: center;
        }

        .connect-message {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }
    </style>
</head>
<body class="overlay-style-default">
    <div id="spotify-container">
        <div id="connect-screen" class="connect-container" style="display: none;">
            <p class="connect-message">Connectez-vous √† Spotify pour afficher la musique en cours</p>
            <button id="connectButton" class="spotify-connect-button">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/>
                </svg>
                Connecter Spotify
            </button>
        </div>
        <div id="spotify-display" class="spotify-track" style="display: none;">
            <div class="vinyl-container">
                <div class="vinyl paused">
                    <div class="vinyl-image" style="background: #1a1a1a;"></div>
                    <div class="vinyl-center"></div>
                </div>
            </div>
            <div class="track-background" style="background: #1a1a1a;"></div>
            <div class="track-info">
                <span class="track-name">Aucune musique en cours</span>
                <span class="track-artist">En attente...</span>
            </div>
        </div>
    </div>

    <script>
        class SpotifyWidget {
            constructor() {
                console.log('üöÄ Initialisation du Spotify Widget');
                console.log('üìç URL actuelle:', window.location.href);

                // Check for Authorization Code callback FIRST - restore params before initializing
                const searchParams = new URLSearchParams(window.location.search);
                const code = searchParams.get('code');

                // If we're in the OAuth callback, check and clean invalid code_verifier first
                if (code) {
                    const oldCodeVerifier = sessionStorage.getItem('spotify_code_verifier');
                    if (oldCodeVerifier && oldCodeVerifier.length > 128) {
                        console.warn('üßπ Nettoyage d\'un ancien code_verifier invalide (encod√© en Base64, longueur:', oldCodeVerifier.length, ')');
                        sessionStorage.removeItem('spotify_code_verifier');
                    }

                    const savedParams = sessionStorage.getItem('spotify_widget_params');
                    console.log('üîç V√©rification sessionStorage (callback OAuth):', savedParams ? 'pr√©sent' : 'absent');
                    if (savedParams) {
                        try {
                            const params = JSON.parse(savedParams);
                            console.log('üîÑ Param√®tres restaur√©s depuis sessionStorage (callback OAuth):', params);
                            // Temporarily set these for the callback handler
                            this.clientId = params.client_id || '';
                            this.redirectUri = (params.redirect_uri || 'https://jaysonpasquier.github.io/GitViz/overlay/spotify/spotify-widget.html').replace(/\/$/, '');
                            console.log('‚úÖ client_id restaur√©:', this.clientId ? 'pr√©sent (' + this.clientId.substring(0, 10) + '...)' : 'absent');
                            console.log('‚úÖ redirect_uri restaur√©:', this.redirectUri);
                        } catch (e) {
                            console.error('‚ùå Erreur lors de la restauration des param√®tres:', e);
                        }
                    } else {
                        console.error('‚ùå Aucun param√®tre sauvegard√© trouv√© dans sessionStorage. Les param√®tres doivent √™tre sauvegard√©s avant la redirection OAuth.');
                    }
                }

                // Get credentials from URL parameters or restored parameters
                const urlParams = new URLSearchParams(window.location.search);

                // Try to restore saved parameters (if not already done for callback)
                if (!code) {
                    const savedParams = sessionStorage.getItem('spotify_widget_params');
                    if (savedParams) {
                        try {
                            const params = JSON.parse(savedParams);
                            console.log('üîÑ Param√®tres restaur√©s depuis sessionStorage:', params);
                            // Merge with URL params (URL params take priority)
                            urlParams.forEach((value, key) => {
                                if (key !== 'code' && key !== 'state' && key !== 'error') {
                                    params[key] = value;
                                }
                            });
                            this.clientId = params.client_id || '';
                            this.redirectUri = (params.redirect_uri || 'https://jaysonpasquier.github.io/GitViz/overlay/spotify/spotify-widget.html').replace(/\/$/, '');
                        } catch (e) {
                            console.error('Erreur lors de la restauration des param√®tres:', e);
                        }
                    }
                }

                // If not restored from sessionStorage, get from URL
                if (!this.clientId) {
                    this.clientId = urlParams.get('client_id') || '';
                }
                if (!this.redirectUri) {
                    // Default to the production URL (HTTPS required by Spotify)
                    let redirectUri = urlParams.get('redirect_uri') || 'https://jaysonpasquier.github.io/GitViz/overlay/spotify/spotify-widget.html';
                    // Remove trailing slash if present
                    redirectUri = redirectUri.replace(/\/$/, '');
                    this.redirectUri = redirectUri;
                }

                this.scope = 'user-read-currently-playing';

                console.log('üîë Client ID:', this.clientId ? 'pr√©sent' : 'absent');
                console.log('üîó Redirect URI utilis√©:', this.redirectUri);
                console.log('‚ö†Ô∏è IMPORTANT: Cette URL doit correspondre EXACTEMENT √† celle dans Spotify Dashboard');
                console.log('‚ö†Ô∏è V√©rifiez: m√™me protocole (http/https), m√™me port, pas de slash final');
                this.updateInterval = parseInt(urlParams.get('update_interval')) || 2000;
                this.font = urlParams.get('font') || 'Arial';
                this.fontSize = parseInt(urlParams.get('font_size')) || 24;
                this.fontEffect = urlParams.get('font_effect') || 'normal';
                this.overlayStyle = urlParams.get('overlay_style') || 'default';

                this.currentTrack = null;
                this.updateIntervalId = null;

                this.display = document.getElementById('spotify-display');
                this.connectScreen = document.getElementById('connect-screen');
                this.connectButton = document.getElementById('connectButton');

                this.applyFont(this.font);
                this.applyStyles();
                this.applyOverlayStyle();

                // Handle OAuth callback if present
                if (code) {
                    this.handleAuthorizationCodeCallback(code);
                    return;
                }

                // Check if credentials are provided
                if (!this.clientId) {
                    console.log('‚ö†Ô∏è Client ID manquant, affichage de l\'√©cran de connexion');
                    this.showConnectScreen();
                    return;
                }

                // Try to get token from localStorage
                const tokenData = this.getStoredTokenData();
                if (tokenData && !this.isTokenExpired(tokenData)) {
                    this.accessToken = tokenData.token;
                    this.refreshToken = tokenData.refreshToken;
                    console.log('‚úÖ Token valide trouv√© dans localStorage');
                    this.showWidget();
                    this.startPolling();

                    // Set up token refresh (every 50 minutes)
                    this.tokenRefreshInterval = setInterval(async () => {
                        if (this.refreshToken) {
                            console.log('üîÑ Rafra√Æchissement automatique du token...');
                            try {
                                const newTokenData = await this.refreshAccessToken(this.refreshToken);
                                this.saveTokenData(newTokenData);
                                this.accessToken = newTokenData.accessToken;
                                this.refreshToken = newTokenData.refreshToken;
                                console.log('‚úÖ Token rafra√Æchi avec succ√®s');
                            } catch (error) {
                                console.error('‚ùå Erreur lors du rafra√Æchissement:', error);
                                this.showConnectScreen();
                            }
                        }
                    }, 50 * 60 * 1000);
                    return;
                }

                // No valid token, show connect screen
                console.log('‚ö†Ô∏è Pas de token valide, affichage de l\'√©cran de connexion');
                this.showConnectScreen();
            }

            handleOAuthCallback() {
                const hash = window.location.hash.substring(1);
                console.log('üîç Analyse du hash:', hash || 'vide');

                if (!hash) {
                    console.log('‚ÑπÔ∏è Pas de hash dans l\'URL');
                    return;
                }

                const params = new URLSearchParams(hash);
                const accessToken = params.get('access_token');
                const expiresIn = params.get('expires_in');
                const error = params.get('error');
                const errorDescription = params.get('error_description');

                console.log('üîç Param√®tres extraits:', {
                    hasToken: !!accessToken,
                    expiresIn: expiresIn,
                    error: error,
                    errorDescription: errorDescription
                });

                // Handle errors
                if (error) {
                    console.error('‚ùå Erreur OAuth Spotify:', error, errorDescription);
                    let errorMessage = 'Erreur de connexion Spotify. ';

                    if (error === 'unsupported_response_type') {
                        errorMessage = 'Le flux Implicit Grant n\'est pas activ√© dans votre application Spotify.';
                        console.error('‚ùå Implicit Grant non activ√©. Instructions:');
                        console.log('1. Allez sur https://developer.spotify.com/dashboard');
                        console.log('2. Ouvrez votre application');
                        console.log('3. Cliquez sur "Edit Settings"');
                        console.log('4. Dans "Redirect URIs", assurez-vous que votre URL est ajout√©e');
                        console.log('5. Cochez la case "Implicit Grant"');
                        console.log('6. Cliquez sur "Save"');
                        console.log('7. R√©essayez la connexion');
                        this.showErrorWithInstructions(errorMessage);
                    } else if (error === 'access_denied') {
                        errorMessage = 'Connexion annul√©e par l\'utilisateur.';
                        this.showError(errorMessage);
                    } else {
                        errorMessage += `Erreur: ${errorDescription || error}`;
                        this.showError(errorMessage);
                    }

                    // Clean URL (remove hash)
                    const cleanUrl = window.location.origin + window.location.pathname + window.location.search;
                    window.history.replaceState({}, document.title, cleanUrl);
                    return;
                }

                if (accessToken) {
                    console.log('‚úÖ Token re√ßu! Expires in:', expiresIn, 'seconds');

                    // Store token in localStorage
                    const tokenData = {
                        token: accessToken,
                        expiresAt: Date.now() + (parseInt(expiresIn) * 1000)
                    };
                    localStorage.setItem('spotify_access_token', JSON.stringify(tokenData));
                    console.log('üíæ Token sauvegard√© dans localStorage');

                    // Restore saved parameters
                    const savedParams = sessionStorage.getItem('spotify_widget_params');
                    let cleanUrl = window.location.origin + window.location.pathname;

                    if (savedParams) {
                        try {
                            const params = JSON.parse(savedParams);
                            const urlParams = new URLSearchParams();
                            Object.keys(params).forEach(key => {
                                urlParams.set(key, params[key]);
                            });
                            const queryString = urlParams.toString();
                            if (queryString) {
                                cleanUrl += '?' + queryString;
                            }
                            sessionStorage.removeItem('spotify_widget_params');
                            console.log('üîÑ Param√®tres restaur√©s:', params);
                        } catch (e) {
                            console.error('Erreur lors de la restauration des param√®tres:', e);
                        }
                    } else {
                        // Keep current search params if no saved ones
                        if (window.location.search) {
                            cleanUrl += window.location.search;
                        }
                    }

                    // Clean URL (remove hash, restore params)
                    window.history.replaceState({}, document.title, cleanUrl);
                    console.log('üßπ URL nettoy√©e et param√®tres restaur√©s:', cleanUrl);

                    // Reload to use the new token with restored parameters
                    console.log('üîÑ Rechargement de la page...');
                    window.location.reload();
                } else {
                    console.log('‚ö†Ô∏è Pas de token dans le hash');
                }
            }

            getAccessToken() {
                // Check localStorage
                try {
                    const stored = localStorage.getItem('spotify_access_token');
                    if (stored) {
                        const tokenData = JSON.parse(stored);
                        // Check if token is still valid (not expired)
                        if (tokenData.expiresAt && Date.now() < tokenData.expiresAt) {
                            return tokenData.token;
                        } else {
                            // Token expired, remove it
                            localStorage.removeItem('spotify_access_token');
                        }
                    }
                } catch (e) {
                    console.error('Error reading token from localStorage:', e);
                }

                return null;
            }

            isTokenExpired() {
                try {
                    const stored = localStorage.getItem('spotify_access_token');
                    if (stored) {
                        const tokenData = JSON.parse(stored);
                        if (tokenData.expiresAt) {
                            return Date.now() >= tokenData.expiresAt;
                        }
                    }
                } catch (e) {
                    console.error('Error checking token expiration:', e);
                }
                return true;
            }

            // Generate PKCE code verifier and challenge
            // According to PKCE spec: code_verifier is a random string, code_challenge is Base64URL(SHA256(code_verifier))
            async generatePKCE() {
                // Generate a random string of 43-128 characters (URL-safe)
                const codeVerifier = this.generateRandomString(128);
                // Hash the code_verifier (as ASCII string) and encode in Base64 URL
                const hash = await this.sha256(codeVerifier);
                const codeChallenge = this.base64URLEncode(hash);
                console.log('üîê PKCE g√©n√©r√©:', {
                    codeVerifier_length: codeVerifier.length,
                    codeChallenge_length: codeChallenge.length,
                    codeVerifier_preview: codeVerifier.substring(0, 20) + '...'
                });
                return { codeVerifier, codeChallenge };
            }

            generateRandomString(length) {
                const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let text = '';
                for (let i = 0; i < length; i++) {
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                }
                return text;
            }

            base64URLEncode(str) {
                if (str instanceof Uint8Array) {
                    return btoa(String.fromCharCode.apply(null, str))
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_')
                        .replace(/=/g, '');
                }
                return btoa(str)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            async sha256(plain) {
                // Encode the string as UTF-8 (ASCII for PKCE)
                const encoder = new TextEncoder();
                const data = encoder.encode(plain);
                // Hash using Web Crypto API
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                return new Uint8Array(hashBuffer);
            }

            async fetchAccessToken() {
                if (!this.clientId) {
                    console.error('‚ùå Client ID manquant');
                    return;
                }

                // Save current parameters to restore after OAuth redirect
                const currentParams = new URLSearchParams(window.location.search);
                const paramsToSave = {};
                currentParams.forEach((value, key) => {
                    if (key !== 'code' && key !== 'state' && key !== 'error') {
                        paramsToSave[key] = value;
                    }
                });

                // Also save current instance values (important for client_id and redirect_uri)
                paramsToSave.client_id = this.clientId;
                paramsToSave.redirect_uri = this.redirectUri;

                // Store parameters in sessionStorage
                sessionStorage.setItem('spotify_widget_params', JSON.stringify(paramsToSave));
                console.log('üíæ Param√®tres sauvegard√©s:', paramsToSave);

                // Clear any old code_verifier first (in case of previous failed attempts)
                sessionStorage.removeItem('spotify_code_verifier');

                // Use Authorization Code flow with PKCE (no client_secret needed)
                const { codeVerifier, codeChallenge } = await this.generatePKCE();

                // Verify code_verifier length (should be 43-128 characters, not Base64 encoded)
                if (codeVerifier.length > 128) {
                    console.error('‚ùå Code verifier trop long:', codeVerifier.length);
                    throw new Error('Code verifier invalide: longueur incorrecte');
                }

                // Store code verifier for later use
                sessionStorage.setItem('spotify_code_verifier', codeVerifier);
                console.log('üíæ Code verifier sauvegard√© dans sessionStorage:', {
                    length: codeVerifier.length,
                    preview: codeVerifier.substring(0, 20) + '...',
                    isBase64Encoded: codeVerifier.length > 128 ? 'OUI (ERREUR!)' : 'NON (correct)'
                });

                // Generate state for security
                const state = this.generateRandomString(16);
                sessionStorage.setItem('spotify_oauth_state', state);

                const authUrl = `https://accounts.spotify.com/authorize?` +
                    `client_id=${this.clientId}&` +
                    `response_type=code&` +
                    `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                    `scope=${encodeURIComponent(this.scope)}&` +
                    `code_challenge_method=S256&` +
                    `code_challenge=${codeChallenge}&` +
                    `state=${state}&` +
                    `show_dialog=false`;

                console.log('üîó URL d\'autorisation compl√®te:', authUrl);
                console.log('üîó Redirect URI encod√©:', encodeURIComponent(this.redirectUri));
                console.log('‚ö†Ô∏è V√âRIFIEZ que ce Redirect URI correspond EXACTEMENT √† celui dans Spotify Dashboard');
                console.log('‚ö†Ô∏è Dans Spotify Dashboard, l\'URL doit √™tre EXACTEMENT:', this.redirectUri);
                window.location.href = authUrl;
            }

            async exchangeCodeForToken(code) {
                let codeVerifier = sessionStorage.getItem('spotify_code_verifier');
                if (!codeVerifier) {
                    console.error('‚ùå Code verifier manquant dans sessionStorage');
                    throw new Error('Code verifier manquant');
                }

                // Verify code_verifier is not Base64 encoded (should be 43-128 chars)
                if (codeVerifier.length > 128) {
                    console.error('‚ùå Code verifier invalide: semble √™tre encod√© en Base64 (longueur:', codeVerifier.length, ')');
                    console.error('üßπ Nettoyage de l\'ancien code_verifier invalide...');
                    sessionStorage.removeItem('spotify_code_verifier');

                    // Show error to user and ask them to reconnect
                    this.showError('Code verifier invalide d√©tect√©. Veuillez vous reconnecter en cliquant sur "Connecter Spotify".');
                    this.showConnectScreen();
                    throw new Error('Code verifier invalide: semble √™tre encod√©. Veuillez vous reconnecter.');
                }

                console.log('üîê Code verifier r√©cup√©r√©:', {
                    length: codeVerifier.length,
                    preview: codeVerifier.substring(0, 20) + '...',
                    exists: !!codeVerifier,
                    isValidLength: codeVerifier.length >= 43 && codeVerifier.length <= 128
                });

                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            grant_type: 'authorization_code',
                            code: code,
                            redirect_uri: this.redirectUri,
                            code_verifier: codeVerifier
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch (e) {
                            errorData = { error: 'Unknown error', error_description: errorText };
                        }
                        console.error('‚ùå Erreur API Spotify:', {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorData,
                            requestBody: {
                                client_id: this.clientId ? 'pr√©sent (' + this.clientId.substring(0, 10) + '...)' : 'absent',
                                redirect_uri: this.redirectUri,
                                has_code_verifier: !!codeVerifier
                            }
                        });
                        throw new Error(errorData.error_description || errorData.error || 'Erreur lors de l\'√©change du code');
                    }

                    const data = await response.json();
                    return {
                        accessToken: data.access_token,
                        refreshToken: data.refresh_token,
                        expiresIn: data.expires_in
                    };
                } catch (error) {
                    console.error('‚ùå Erreur lors de l\'√©change du code:', error);
                    throw error;
                }
            }

            async refreshAccessToken(refreshToken) {
                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            grant_type: 'refresh_token',
                            refresh_token: refreshToken
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Erreur lors du rafra√Æchissement du token');
                    }

                    const data = await response.json();
                    return {
                        accessToken: data.access_token,
                        refreshToken: data.refresh_token || refreshToken, // Keep old refresh token if new one not provided
                        expiresIn: data.expires_in
                    };
                } catch (error) {
                    console.error('‚ùå Erreur lors du rafra√Æchissement:', error);
                    throw error;
                }
            }

            showConnectScreen() {
                console.log('üì∫ Affichage de l\'√©cran de connexion');
                if (this.connectScreen) {
                    this.connectScreen.style.display = 'flex';

                    if (!this.clientId) {
                        this.connectScreen.innerHTML = `
                            <p class="connect-message" style="margin-bottom: 16px;">Configuration requise</p>
                            <p class="connect-message" style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-bottom: 20px;">
                                Veuillez fournir votre Client ID dans les param√®tres de l'URL.
                            </p>
                            <div style="text-align: left; max-width: 500px; margin: 0 auto; padding: 16px; background: rgba(33, 150, 243, 0.1); border-radius: 8px; border-left: 3px solid #2196F3;">
                                <p style="margin: 0; color: rgba(255, 255, 255, 0.9); font-size: 13px;">
                                    Exemple d'URL :<br>
                                    <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 11px; display: block; margin: 8px 0; word-break: break-all;">
                                        ?client_id=VOTRE_CLIENT_ID&redirect_uri=http://localhost:3000
                                    </code>
                                </p>
                            </div>
                        `;
                    } else {
                        // Show connect button
                        if (this.connectButton) {
                            const newButton = this.connectButton.cloneNode(true);
                            this.connectButton.parentNode.replaceChild(newButton, this.connectButton);
                            this.connectButton = newButton;

                            this.connectButton.addEventListener('click', async () => {
                                console.log('üñ±Ô∏è Clic sur le bouton de connexion');
                                await this.fetchAccessToken();
                            });
                        }
                    }
                }
                if (this.display) {
                    this.display.style.display = 'none';
                }
            }

            showWidget() {
                if (this.connectScreen) {
                    this.connectScreen.style.display = 'none';
                }
                if (this.display) {
                    this.display.style.display = 'flex';
                }
            }

            initiateOAuth() {
                console.log('üöÄ D√©marrage du flux OAuth');
                console.log('üîó Redirect URI:', this.redirectUri);
                // Try Implicit Grant flow first (works client-side without backend)
                this.initiateImplicitGrantFlow();
            }

            initiateAuthorizationCodeFlow() {
                // Generate a random state for security
                const state = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                sessionStorage.setItem('spotify_oauth_state', state);

                // Log the redirect URI for debugging
                console.log('üîó Redirect URI utilis√©:', this.redirectUri);
                console.log('üîó URL compl√®te actuelle:', window.location.href);

                const authUrl = `https://accounts.spotify.com/authorize?` +
                    `client_id=${this.clientId}&` +
                    `response_type=code&` +
                    `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                    `scope=${encodeURIComponent(this.scope)}&` +
                    `state=${state}&` +
                    `show_dialog=false`;

                console.log('üîó URL d\'autorisation (Authorization Code):', authUrl);
                window.location.href = authUrl;
            }

            async handleAuthorizationCodeCallback(code) {
                const urlParams = new URLSearchParams(window.location.search);
                const state = urlParams.get('state');
                const error = urlParams.get('error');

                if (error) {
                    console.error('‚ùå Erreur OAuth Spotify:', error);
                    this.showError(`Erreur de connexion: ${error}`);
                    const cleanUrl = window.location.origin + window.location.pathname + window.location.search.replace(/[?&]code=[^&]*/, '').replace(/[?&]state=[^&]*/, '').replace(/[?&]error=[^&]*/, '');
                    window.history.replaceState({}, document.title, cleanUrl);
                    return;
                }

                // Verify state
                const storedState = sessionStorage.getItem('spotify_oauth_state');
                if (state !== storedState) {
                    console.error('‚ùå √âtat OAuth invalide');
                    this.showError('Erreur de s√©curit√© lors de la connexion.');
                    sessionStorage.removeItem('spotify_oauth_state');
                    return;
                }
                sessionStorage.removeItem('spotify_oauth_state');

                if (code) {
                    try {
                        // client_id and redirect_uri should already be restored in constructor
                        // But double-check from saved parameters if needed
                        if (!this.clientId) {
                            const savedParams = sessionStorage.getItem('spotify_widget_params');
                            if (savedParams) {
                                try {
                                    const params = JSON.parse(savedParams);
                                    if (params.client_id) {
                                        this.clientId = params.client_id;
                                        console.log('üîÑ Client ID restaur√© (fallback):', this.clientId);
                                    }
                                    if (params.redirect_uri) {
                                        this.redirectUri = params.redirect_uri.replace(/\/$/, '');
                                        console.log('üîÑ Redirect URI restaur√© (fallback):', this.redirectUri);
                                    }
                                } catch (e) {
                                    console.error('Erreur lors de la restauration des param√®tres:', e);
                                }
                            }
                        }

                        if (!this.clientId) {
                            throw new Error('Client ID manquant apr√®s la redirection. V√©rifiez que client_id est dans l\'URL initiale.');
                        }

                        console.log('üîÑ √âchange du code d\'autorisation contre un token...');
                        console.log('üîë Client ID utilis√©:', this.clientId);
                        console.log('üîó Redirect URI utilis√©:', this.redirectUri);

                        const tokenData = await this.exchangeCodeForToken(code);

                        // Save token data
                        this.saveTokenData(tokenData);
                        this.accessToken = tokenData.accessToken;
                        this.refreshToken = tokenData.refreshToken;

                        console.log('‚úÖ Token obtenu avec succ√®s');

                        // Restore saved parameters in URL
                        let cleanUrl = window.location.origin + window.location.pathname;

                        if (savedParams) {
                            try {
                                const params = JSON.parse(savedParams);
                                const urlParams = new URLSearchParams();
                                Object.keys(params).forEach(key => {
                                    if (key !== 'client_id' && key !== 'redirect_uri') {
                                        urlParams.set(key, params[key]);
                                    }
                                });
                                const queryString = urlParams.toString();
                                if (queryString) {
                                    cleanUrl += '?' + queryString;
                                }
                                sessionStorage.removeItem('spotify_widget_params');
                                console.log('üîÑ Param√®tres restaur√©s dans l\'URL');
                            } catch (e) {
                                console.error('Erreur lors de la restauration des param√®tres:', e);
                            }
                        }

                        // Clean URL (remove code and state)
                        window.history.replaceState({}, document.title, cleanUrl);

                        // Show widget and start polling
                        this.showWidget();
                        this.startPolling();

                        // Set up token refresh
                        this.tokenRefreshInterval = setInterval(async () => {
                            if (this.refreshToken) {
                                console.log('üîÑ Rafra√Æchissement automatique du token...');
                                try {
                                    const newTokenData = await this.refreshAccessToken(this.refreshToken);
                                    this.saveTokenData(newTokenData);
                                    this.accessToken = newTokenData.accessToken;
                                    this.refreshToken = newTokenData.refreshToken;
                                    console.log('‚úÖ Token rafra√Æchi avec succ√®s');
                                } catch (error) {
                                    console.error('‚ùå Erreur lors du rafra√Æchissement:', error);
                                    this.showConnectScreen();
                                }
                            }
                        }, 50 * 60 * 1000);

                    } catch (error) {
                        console.error('‚ùå Erreur lors de l\'√©change du code:', error);
                        this.showError('Erreur lors de la connexion: ' + error.message);
                    }
                }
            }

            getStoredTokenData() {
                try {
                    const stored = localStorage.getItem('spotify_access_token');
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (e) {
                    console.error('Error reading token from localStorage:', e);
                }
                return null;
            }

            saveTokenData(tokenData) {
                const dataToStore = {
                    token: tokenData.accessToken,
                    refreshToken: tokenData.refreshToken,
                    expiresAt: Date.now() + (tokenData.expiresIn * 1000)
                };
                localStorage.setItem('spotify_access_token', JSON.stringify(dataToStore));
            }

            isTokenExpired(tokenData) {
                if (tokenData && tokenData.expiresAt) {
                    return Date.now() >= tokenData.expiresAt;
                }
                return true;
            }

            showTokenInstructions() {
                if (this.connectScreen) {
                    this.connectScreen.innerHTML = `
                        <p class="connect-message" style="margin-bottom: 16px;">Le flux automatique n'est pas disponible. Veuillez obtenir un token manuellement :</p>
                        <ol style="text-align: left; max-width: 500px; margin: 0 auto 16px; color: rgba(255, 255, 255, 0.8); line-height: 1.8; font-size: 14px;">
                            <li>Allez sur <a href="https://developer.spotify.com/console/get-users-currently-playing-track/" target="_blank" rel="noopener" style="color: #1DB954;">Spotify Web Console</a></li>
                            <li>Cliquez sur "Get Token"</li>
                            <li>S√©lectionnez le scope: <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px;">user-read-currently-playing</code></li>
                            <li>Copiez le token obtenu</li>
                            <li>Ajoutez-le √† l'URL de l'overlay : <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px;">?access_token=VOTRE_TOKEN</code></li>
                        </ol>
                        <button id="retryConnectButton" class="spotify-connect-button" style="margin-top: 8px;">
                            R√©essayer la connexion automatique
                        </button>
                    `;

                    const retryButton = document.getElementById('retryConnectButton');
                    if (retryButton) {
                        retryButton.addEventListener('click', () => {
                            // Try Implicit Grant as fallback
                            this.initiateImplicitGrantFlow();
                        });
                    }
                }
            }

            initiateImplicitGrantFlow() {
                console.log('üîÑ Utilisation du flux Implicit Grant (response_type=token)...');

                // Save current URL parameters to restore them after OAuth
                const currentParams = new URLSearchParams(window.location.search);
                const paramsToSave = {};
                currentParams.forEach((value, key) => {
                    if (key !== 'code' && key !== 'state' && key !== 'error' && key !== 'redirect_uri') {
                        paramsToSave[key] = value;
                    }
                });

                // Store parameters in sessionStorage
                if (Object.keys(paramsToSave).length > 0) {
                    sessionStorage.setItem('spotify_widget_params', JSON.stringify(paramsToSave));
                    console.log('üíæ Param√®tres sauvegard√©s:', paramsToSave);
                }

                // Use base URL without parameters for redirect_uri (Spotify requires exact match)
                // The base redirect URI should be configured in Spotify Dashboard without parameters
                const baseRedirectUri = window.location.origin + window.location.pathname;
                console.log('üîó Redirect URI de base (sans param√®tres):', baseRedirectUri);
                console.log('‚ÑπÔ∏è Assurez-vous que cette URL exacte est configur√©e dans Spotify Dashboard');

                const authUrl = `https://accounts.spotify.com/authorize?` +
                    `client_id=${this.clientId}&` +
                    `response_type=token&` +
                    `redirect_uri=${encodeURIComponent(baseRedirectUri)}&` +
                    `scope=${encodeURIComponent(this.scope)}&` +
                    `show_dialog=false`;

                console.log('üîó URL d\'autorisation compl√®te:', authUrl);
                console.log('‚è≥ Redirection vers Spotify...');
                window.location.href = authUrl;
            }

            applyFont(fontName) {
                if (!fontName) fontName = 'Arial';
                const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];
                let fontFamily;
                if (systemFonts.includes(fontName)) {
                    fontFamily = fontName;
                } else {
                    fontFamily = `'${fontName}'`;
                }
                document.documentElement.style.setProperty('--custom-font', `${fontFamily}, sans-serif`);
                document.body.style.fontFamily = `${fontFamily}, sans-serif`;
            }

            applyStyles() {
                const root = document.documentElement;
                root.style.setProperty('--font-size-main', `${this.fontSize}px`);

                const style = document.createElement('style');
                style.id = 'dynamic-spotify-styles';
                const existingStyle = document.getElementById('dynamic-spotify-styles');
                if (existingStyle) {
                    existingStyle.remove();
                }

                if (this.fontEffect !== 'normal') {
                    style.textContent = `
                        .spotify-track.font-${this.fontEffect} {
                            ${this.getFontEffectCSS(this.fontEffect)}
                        }
                    `;
                    document.head.appendChild(style);
                }

                if (this.display) {
                    this.display.classList.remove('font-normal', 'font-hollow', 'font-border');
                    if (this.fontEffect !== 'normal') {
                        this.display.classList.add(`font-${this.fontEffect}`);
                    }
                }
            }

            getFontEffectCSS(effect) {
                switch(effect) {
                    case 'hollow':
                        return `
                            -webkit-text-stroke: 2px;
                            -webkit-text-stroke-color: currentColor;
                            -webkit-text-fill-color: transparent;
                            color: transparent;
                        `;
                    case 'border':
                        return `
                            text-shadow:
                                -2px -2px 0 currentColor,
                                2px -2px 0 currentColor,
                                -2px 2px 0 currentColor,
                                2px 2px 0 currentColor,
                                0 -2px 0 currentColor,
                                0 2px 0 currentColor,
                                -2px 0 0 currentColor,
                                2px 0 0 currentColor;
                        `;
                    default:
                        return '';
                }
            }

            applyOverlayStyle() {
                const body = document.body;
                if (!body) return;

                body.classList.remove(
                    'overlay-style-default',
                    'overlay-style-card',
                    'overlay-style-bubble',
                    'overlay-style-minimal',
                    'overlay-style-gradient',
                    'overlay-style-glass'
                );

                body.classList.add(`overlay-style-${this.overlayStyle}`);
            }

            async fetchCurrentTrack() {
                try {
                    const response = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (response.status === 204) {
                        // No content - no track playing
                        this.updateDisplay(null);
                        return;
                    }

                    if (response.status === 401) {
                        // Token expired or invalid
                        localStorage.removeItem('spotify_access_token');
                        this.showError('Token d\'acc√®s invalide ou expir√©. Reconnexion n√©cessaire...');
                        this.stopPolling();
                        setTimeout(() => {
                            this.showConnectScreen();
                        }, 2000);
                        return;
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    this.updateDisplay(data);
                } catch (error) {
                    console.error('Erreur lors de la r√©cup√©ration de la piste:', error);
                    if (error.message.includes('401')) {
                        this.showError('Token d\'acc√®s invalide ou expir√©.');
                        this.stopPolling();
                    }
                }
            }

            updateDisplay(trackData) {
                if (!this.display) return;

                if (!trackData || !trackData.item) {
                    if (this.overlayStyle === 'default') {
                        this.display.innerHTML = `
                            <div class="vinyl-container">
                                <div class="vinyl paused">
                                    <div class="vinyl-image" style="background: #1a1a1a;"></div>
                                    <div class="vinyl-center"></div>
                                </div>
                            </div>
                            <div class="track-background" style="background: #1a1a1a;"></div>
                            <div class="track-info">
                                <span class="track-name">Aucune musique en cours</span>
                                <span class="track-artist">En attente...</span>
                            </div>
                        `;
                    } else {
                        this.display.innerHTML = '<span class="no-track">Aucune musique en cours</span>';
                    }
                    this.currentTrack = null;
                    return;
                }

                const track = trackData.item;
                const trackName = track.name;
                const artists = track.artists.map(a => a.name).join(', ');
                const albumImage = track.album?.images?.[0]?.url || track.album?.images?.[1]?.url || track.album?.images?.[2]?.url || '';
                const isPlaying = trackData.is_playing !== false;

                // Only update if track changed
                if (this.currentTrack &&
                    this.currentTrack.name === trackName &&
                    this.currentTrack.artists === artists &&
                    this.currentTrack.albumImage === albumImage) {
                    // Update playing state
                    if (this.overlayStyle === 'default') {
                        const vinyl = this.display.querySelector('.vinyl');
                        if (vinyl) {
                            vinyl.classList.toggle('playing', isPlaying);
                            vinyl.classList.toggle('paused', !isPlaying);
                        }
                    }
                    return;
                }

                this.currentTrack = { name: trackName, artists: artists, albumImage: albumImage };

                if (this.overlayStyle === 'default') {
                    this.display.innerHTML = `
                        <div class="vinyl-container">
                            <div class="vinyl ${isPlaying ? 'playing' : 'paused'}">
                                ${albumImage ? `<img class="vinyl-image" src="${this.escapeHtml(albumImage)}" alt="Album" onerror="this.style.display='none'; this.parentElement.style.background='radial-gradient(circle at center, #1a1a1a 0%, #1a1a1a 30%, #2a2a2a 30%, #2a2a2a 35%, #1a1a1a 35%, #1a1a1a 100%)';">` : '<div class="vinyl-image" style="background: #1a1a1a;"></div>'}
                                <div class="vinyl-center"></div>
                            </div>
                        </div>
                        ${albumImage ? `<div class="track-background" style="background-image: url('${this.escapeHtml(albumImage)}');"></div>` : '<div class="track-background" style="background: #1a1a1a;"></div>'}
                        <div class="track-info">
                            <span class="track-name">${this.escapeHtml(trackName)}</span>
                            <span class="track-artist">${this.escapeHtml(artists)}</span>
                        </div>
                    `;
                } else {
                    this.display.innerHTML = `
                        <svg class="spotify-icon" viewBox="0 0 24 24" fill="#1DB954">
                            <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/>
                        </svg>
                        <div class="track-info">
                            <span class="track-name">${this.escapeHtml(trackName)}</span>
                            <span class="track-separator">‚Ä¢</span>
                            <span class="track-artist">${this.escapeHtml(artists)}</span>
                        </div>
                    `;
                }

                // Reapply font effect
                if (this.fontEffect !== 'normal') {
                    this.display.classList.add(`font-${this.fontEffect}`);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showError(message) {
                if (this.display) {
                    this.display.innerHTML = `<span class="error-message">${this.escapeHtml(message)}</span>`;
                }
            }

            showErrorWithInstructions(message) {
                if (this.connectScreen) {
                    this.connectScreen.innerHTML = `
                        <p class="connect-message" style="color: #ff6b6b; margin-bottom: 16px;">${this.escapeHtml(message)}</p>
                        <div style="text-align: left; max-width: 600px; margin: 0 auto 20px; padding: 16px; background: rgba(255, 107, 107, 0.1); border-radius: 8px; border-left: 3px solid #ff6b6b;">
                            <h4 style="margin: 0 0 12px 0; font-size: 16px; color: #fff;">Comment activer Implicit Grant :</h4>
                            <ol style="margin: 0; padding-left: 20px; color: rgba(255, 255, 255, 0.9); line-height: 1.8; font-size: 14px;">
                                <li>Allez sur <a href="https://developer.spotify.com/dashboard" target="_blank" rel="noopener" style="color: #1DB954; text-decoration: underline;">Spotify Developer Dashboard</a></li>
                                <li>Ouvrez votre application</li>
                                <li>Cliquez sur <strong>"Edit Settings"</strong></li>
                                <li>Dans la section <strong>"Redirect URIs"</strong>, ajoutez <strong>EXACTEMENT</strong> cette URL (sans param√®tres) :<br>
                                    <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 12px; display: block; margin: 4px 0; word-break: break-all;">https://jaysonpasquier.github.io/GitViz/overlay/spotify/spotify-widget.html</code><br>
                                    <strong style="color: #ff6b6b;">‚ö†Ô∏è IMPORTANT :</strong> L'URL doit √™tre exactement celle-ci, sans param√®tres (pas de ? ou &)
                                </li>
                                <li>Cochez la case <strong>"Implicit Grant"</strong> (dans les options avanc√©es ou en bas de la page)</li>
                                <li>Cliquez sur <strong>"Save"</strong></li>
                                <li>Revenez ici et cliquez sur "R√©essayer"</li>
                            </ol>
                        </div>
                        <button id="retryConnectButton" class="spotify-connect-button">
                            R√©essayer la connexion
                        </button>
                    `;

                    this.connectScreen.style.display = 'flex';
                    const retryButton = document.getElementById('retryConnectButton');
                    if (retryButton) {
                        retryButton.addEventListener('click', () => {
                            // Clean URL first
                            const cleanUrl = window.location.origin + window.location.pathname + window.location.search;
                            window.history.replaceState({}, document.title, cleanUrl);
                            this.showConnectScreen();
                        });
                    }
                }
                if (this.display) {
                    this.display.style.display = 'none';
                }
            }

            startPolling() {
                this.fetchCurrentTrack();
                this.updateIntervalId = setInterval(() => {
                    this.fetchCurrentTrack();
                }, this.updateInterval);
            }

            stopPolling() {
                if (this.updateIntervalId) {
                    clearInterval(this.updateIntervalId);
                    this.updateIntervalId = null;
                }
            }
        }

        // Initialize widget when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.spotifyWidget = new SpotifyWidget();
            });
        } else {
            window.spotifyWidget = new SpotifyWidget();
        }
    </script>
</body>
</html>

