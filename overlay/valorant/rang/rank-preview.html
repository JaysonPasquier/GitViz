<!DOCTYPE html>
<!-- GitVize ‚Äì URL Builder & Editor
* what are you doing here ?
* are you trying to copy my code ? or looking if its ai generated ?
* if you are, you are not gonna find anything here.
* this is a custom code that i wrote for my own use.
* if you want to use it, you can, but you need to ask me for permission.
* if you are not trying to copy my code, or looking if its ai generated, then you can continue.
* i hope you enjoy my code.
* if you have any questions, feel free to ask me.
* if you have any suggestions, feel free to suggest them.
* if you have any bugs, feel free to report them.
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Rank Widget</title>
    <!-- Google Fonts for custom font selection -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Poppins:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Raleway:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Ubuntu:wght@400;700&family=Nunito:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Crimson+Text:wght@400;700&family=Libre+Baskerville:wght@400;700&family=PT+Sans:wght@400;700&family=PT+Serif:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Bebas+Neue&family=Anton&family=Fjalla+One&family=Righteous&family=Bangers&family=Fredoka+One:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&family=Work+Sans:wght@400;700&family=Space+Grotesk:wght@400;700&family=DM+Sans:wght@400;700&family=Manrope:wght@400;700&family=Sora:wght@400;700&family=Outfit:wght@400;700&family=Plus+Jakarta+Sans:wght@400;700&family=Figtree:wght@400;700&family=Geist:wght@400;700&family=JetBrains+Mono:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
        <!--
        ========================================
        PARAM√àTRES URL DISPONIBLES
        ========================================

        üéÆ CONFIGURATION DU JOUEUR:
        ?name=JoueurName&tag=TagName

        üîë CONFIGURATION API:
        ?api_key=YOUR_API_KEY&region=eu&platform=pc

        ‚è∞ INTERVALLE DE MISE √Ä JOUR:
        ?update_interval=30000 (en millisecondes, d√©faut: 60000)

        üì∫ CONFIGURATION TWITCH:
        ?channel=nom_canal&nick=nom_utilisateur&pass=mot_de_passe

        üëÆ CONFIGURATION DES PERMISSIONS:
        ?moderators=user1,user2,user3&vips=user1,user2&blacklist=user1,user2

        üèÜ AFFICHAGE LEADERBOARD:
        ?show_leaderboard=true  (affiche la position ~#3042)
        ?show_leaderboard=false (masque la position, affiche seulement rang + RR)

        üìù EXEMPLE COMPLET:
        ?name=ANAKINSKYWALKER&tag=HARR&api_key=YOUR_KEY&region=na&platform=pc&&update_interval=30000&show_leaderboard=true

        ========================================
        COMMANDES DE CHAT DISPONIBLES
        ========================================

        üéÆ !showrank    - Affiche le widget de rang (Mod√©rateurs + VIPs uniquement)
        üôà !hiderank    - Masque le widget de rang (Mod√©rateurs + VIPs uniquement)
        üîÑ !refreshrank - Recharge la page (Mod√©rateurs + VIPs uniquement)
        üîÑ !rankreload  - Recharge la page (Mod√©rateurs + VIPs uniquement)

        üß™ TESTS (Console):
        window.valorantWidget.testCommandPermissions('username')
        window.valorantWidget.testRefreshRank()
        window.valorantWidget.reloadConfiguration()
        window.valorantWidget.generateConfigURL()
        ========================================
        -->
    <style>
        /* Fonts are loaded via Google Fonts in the head */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent !important;
        }

        body {
            font-family: var(--custom-font, 'Arial', sans-serif);
            color: #ffffff;
            position: relative;
            min-height: 100%;
        }

        .preview-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            object-fit: cover;
            pointer-events: none;
        }

        .rank-container {
            display: flex;
            align-items: center;
            gap: 20px;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center;
            z-index: 10;
        }

        .rank-icon {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-icon img {
            width: 80px;
            height: 80px;
            object-fit: contain;
        }

        .rank-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .leaderboard-position {
            font-size: 32px;
            font-weight: bold;
            color: #ff6b6b;
            position: relative;
        }

        .rr-display {
            font-size: 32px;
            font-weight: bold;
            color: #ffffff;
            position: relative;
        }

        .rr-change {
            position: absolute;
            left: -80px;
            top: 0;
            font-size: 20px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(0);
            animation: slideAndFade 2s ease-out forwards;
            pointer-events: none;
        }

        .rr-change.positive {
            color: #00ff00;
        }

        .rr-change.negative {
            color: #ff0000;
        }

        .position-change {
            position: absolute;
            top: -30px;
            right: 0;
            font-size: 16px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(0);
            animation: slideAndFade 3s ease-out forwards;
            pointer-events: none;
        }

        .position-change.up {
            color: #00ff00;
        }

        .position-change.down {
            color: #ff0000;
        }

        @keyframes slideAndFade {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            50% {
                opacity: 1;
                transform: translateY(-10px);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .loading {
            font-size: 16px;
        }

        .error {
            color: #ff0000;
        }

        /* Command feedback styles */
        .command-feedback {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .command-feedback.show {
            opacity: 1;
            transform: translateX(0);
        }

        .command-feedback.success {
            background-color: #00ff00;
            color: #000;
        }

        .command-feedback.error {
            background-color: #ff0000;
        }

        /* Overlay visibility control */
        body.hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <img src="valorant-preview-background.jpg" alt="" class="preview-background" />
    <div class="rank-container" id="rankContainer">
        <div class="rank-icon" id="rankIcon">
            <!-- Will be populated dynamically -->
        </div>
        <div class="rank-info">
            <div class="leaderboard-position" id="leaderboardPosition" style="position: relative;">#----</div>
            <div class="rr-display" id="rrDisplay">-- RR</div>
        </div>
    </div>

    <!-- Command feedback element -->
    <div class="command-feedback" id="commandFeedback"></div>

    <script>
        class ValorantRankWidget {
            constructor() {
                // Get all customizable values from URL parameters
                const urlParams = new URLSearchParams(window.location.search);

                // Player info
                this.playerName = urlParams.get('name') || 'username';
                this.playerTag = urlParams.get('tag') || 'tags';

                // API configuration - check if values are actually in URL
                const apiKeyParam = urlParams.get('api_key');
                const regionParam = urlParams.get('region');
                const platformParam = urlParams.get('platform');

                this.apiKey = apiKeyParam || 'api_key';
                this.apiRegion = regionParam || 'region';
                this.apiPlatform = platformParam || 'plateforme';

                const fontParam = urlParams.get('font') || 'Arial';
                console.log('üî§ Font parameter from URL:', fontParam);
                this.applyFont(fontParam);


                this.updateInterval = parseInt(urlParams.get('update_interval')) || 3000;

                const hasAllInfo = this.playerName &&
                                   this.playerName !== 'username' &&
                                   this.playerTag &&
                                   this.playerTag !== 'tags' &&
                                   apiKeyParam &&
                                   apiKeyParam !== 'api_key' &&
                                   apiKeyParam.trim() !== '' &&
                                   regionParam &&
                                   regionParam !== 'region' &&
                                   regionParam.trim() !== '' &&
                                   platformParam &&
                                   platformParam !== 'plateforme' &&
                                   platformParam.trim() !== '';

                console.log('üîç D√©tection des informations:', {
                    playerName: this.playerName,
                    playerTag: this.playerTag,
                    apiKey: apiKeyParam ? 'pr√©sent' : 'manquant',
                    region: regionParam ? 'pr√©sent' : 'manquant',
                    platform: platformParam ? 'pr√©sent' : 'manquant',
                    hasAllInfo: hasAllInfo
                });

                this.isPreviewMode = !hasAllInfo;

                if (this.isPreviewMode) {
                    console.log('üé≠ Mode preview activ√© - donn√©es mock√©es (informations manquantes)');
                    this.previewStateIndex = 0;
                    this.previewStates = [
                        {
                            rank: 'Ascendant 3',
                            rr: 67,
                            tier: 23,
                            leaderboard: null
                        },
                        {
                            rank: 'Immortal 1',
                            rr: 67,
                            tier: 24,
                            leaderboard: 1111
                        }
                    ];
                } else {
                    console.log('‚úÖ Mode r√©el activ√© - chargement des vraies donn√©es depuis l\'API');
                    if (!urlParams.get('update_interval')) {
                        this.updateInterval = 60000;
                    }
                }

                // Twitch chat configuration
                this.twitchChannel = urlParams.get('channel') || 'twitch_channel';
                this.twitchNick = urlParams.get('nick') || 'justinfan12345';
                this.twitchPass = urlParams.get('pass') || 'SCHMOOPIIE';

                // Leaderboard display configuration
                const showLeaderboardParam = urlParams.get('show_leaderboard');
                this.showLeaderboard = showLeaderboardParam === null ? true : showLeaderboardParam === 'true';

                this.moderators = this.parseUserList(urlParams.get('moderators'));
                this.vips = this.parseUserList(urlParams.get('vips'));
                this.blacklist = this.parseUserList(urlParams.get('blacklist'));

                if (this.moderators.length === 0) {
                    this.moderators = ['sc0rpio74890'];
                }
                if (this.vips.length === 0) {
                    this.vips = ['sc0rpio74890'];
                }
                if (this.blacklist.length === 0) {
                    this.blacklist = ['banned_user1', 'banned_user2'];
                }

                this.isOverlayVisible = true;

                const initialState = this.previewStates[0];
                this.currentRankData = {
                    rank: initialState.rank,
                    rr: initialState.rr,
                    tier: initialState.tier
                };
                this.currentLeaderboardData = initialState.leaderboard ? {
                    leaderboard_rank: initialState.leaderboard,
                    estimated: false
                } : null;

                this.previousPosition = null;

                this.previousRR = initialState.rr;
                this.lastChange = null;
                this.isAnimating = false;
                this.isPositionAnimating = false;

                this.previewIntervalId = null;
                this.realDataIntervalId = null;

                this.rankImages = {
                    3: 'images/Iron_1_Rank.png',
                    4: 'images/Iron_2_Rank.png',
                    5: 'images/Iron_3_Rank.png',
                    6: 'images/Bronze_1_Rank.png',
                    7: 'images/Bronze_2_Rank.png',
                    8: 'images/Bronze_3_Rank.png',
                    9: 'images/Silver_1_Rank.png',
                    10: 'images/Silver_2_Rank.png',
                    11: 'images/Silver_3_Rank.png',
                    12: 'images/Gold_1_Rank.png',
                    13: 'images/Gold_2_Rank.png',
                    14: 'images/Gold_3_Rank.png',
                    15: 'images/Platinum_1_Rank.png',
                    16: 'images/Platinum_2_Rank.png',
                    17: 'images/Platinum_3_Rank.png',
                    18: 'images/Diamond_1_Rank.png',
                    19: 'images/Diamond_2_Rank.png',
                    20: 'images/Diamond_3_Rank.png',
                    21: 'images/Ascendant_1_Rank.png',
                    22: 'images/Ascendant_2_Rank.png',
                    23: 'images/Ascendant_3_Rank.png',
                    24: 'images/Immortal_1_Rank.png',
                    25: 'images/Immortal_2_Rank.png',
                    26: 'images/Immortal_3_Rank.png',
                    27: 'images/Radiant_Rank.png'
                };

                this.rankNameToId = {
                    'Iron 1': 3, 'Iron 2': 4, 'Iron 3': 5,
                    'Bronze 1': 6, 'Bronze 2': 7, 'Bronze 3': 8,
                    'Silver 1': 9, 'Silver 2': 10, 'Silver 3': 11,
                    'Gold 1': 12, 'Gold 2': 13, 'Gold 3': 14,
                    'Platinum 1': 15, 'Platinum 2': 16, 'Platinum 3': 17,
                    'Diamond 1': 18, 'Diamond 2': 19, 'Diamond 3': 20,
                    'Ascendant 1': 21, 'Ascendant 2': 22, 'Ascendant 3': 23,
                    'Immortal 1': 24, 'Immortal 2': 25, 'Immortal 3': 26,
                    'Radiant': 27
                };

                this.logConfiguration();

                this.setupURLChangeDetection();

                this.init();
            }

            parseUserList(paramValue) {
                if (!paramValue) return [];
                return paramValue.split(',').map(user => user.trim().toLowerCase()).filter(user => user.length > 0);
            }

            logConfiguration() {
                console.log('üîß Configuration du widget:');
                console.log(`   üë§ Joueur: ${this.playerName}#${this.playerTag}`);
                console.log(`   üåê API: ${this.apiRegion}/${this.apiPlatform} (Key: ${this.apiKey ? '‚úÖ' : '‚ùå'})`);
                console.log(`   ‚è∞ Mise √† jour: ${this.updateInterval}ms`);
                console.log(`   üì∫ Canal Twitch: #${this.twitchChannel}`);
                console.log(`   üèÜ Afficher leaderboard: ${this.showLeaderboard ? '‚úÖ' : '‚ùå'}`);
                console.log(`   üëÆ Mod√©rateurs: ${this.moderators.join(', ')}`);
                console.log(`   üëë VIPs: ${this.vips.join(', ')}`);
                console.log(`   üö´ Blacklist: ${this.blacklist.join(', ')}`);

                if (this.validateConfiguration()) {
                    console.log('‚úÖ Configuration valide, affichage des donn√©es...');
                } else {
                    console.log('‚ùå Configuration invalide, v√©rifiez les param√®tres URL');
                }
            }

            clearOldCachedData() {
                console.log('üßπ Nettoyage des anciennes donn√©es en cache...');

                const keys = Object.keys(localStorage);
                const currentPlayerKey = `valorant-rank-data-${this.playerName}-${this.playerTag}`;
                const currentLeaderboardKey = `valorant-leaderboard-${this.playerName}-${this.playerTag}`;

                keys.forEach(key => {
                    if (key.startsWith('valorant-rank-data-') && key !== currentPlayerKey) {
                        console.log(`üóëÔ∏è Suppression des anciennes donn√©es de rang: ${key}`);
                        localStorage.removeItem(key);
                    }
                    if (key.startsWith('valorant-leaderboard-') && key !== currentLeaderboardKey) {
                        console.log(`üóëÔ∏è Suppression des anciennes donn√©es de leaderboard: ${key}`);
                        localStorage.removeItem(key);
                    }
                });

                console.log('‚úÖ Nettoyage des anciennes donn√©es termin√©');
            }

            async forceRefreshData() {
                console.log('üîÑ For√ßage de la mise √† jour des donn√©es pour', this.playerName, this.playerTag);

                try {
                    this.currentRankData = {
                        rank: 'Loading...',
                        rr: 0,
                        tier: 0
                    };
                    this.currentLeaderboardData = null;

                    this.clearDisplay();

                    await this.fetchRealRankData();

                    setTimeout(async () => {
                        await this.fetchLeaderboardData();
                    }, 2000);

                    console.log('‚úÖ Donn√©es forc√©ment mises √† jour pour', this.playerName, this.playerTag);
                } catch (error) {
                    console.error('‚ùå Erreur lors du for√ßage de la mise √† jour:', error);
                }
            }

            clearDisplay() {
                console.log('üßπ Nettoyage de l\'affichage...');

                const rankIcon = document.getElementById('rankIcon');
                const rrDisplay = document.getElementById('rrDisplay');
                const leaderboardPosition = document.getElementById('leaderboardPosition');

                rankIcon.innerHTML = '<div style="color: #888;">Loading...</div>';

                rrDisplay.textContent = 'Loading...';

                if (leaderboardPosition) {
                    leaderboardPosition.style.display = 'none';
                }

                console.log('‚úÖ Affichage nettoy√©');
            }

            validateConfiguration() {
                console.log('üîç Validation de la configuration...');

                if (!this.playerName || !this.playerTag) {
                    console.error('‚ùå Nom du joueur ou tag manquant');
                    this.showConfigurationError('Nom du joueur ou tag manquant');
                    return false;
                }

                if (!this.apiKey || this.apiKey === 'api_key' || this.apiKey.trim() === '') {
                    console.error('‚ùå Cl√© API manquante ou cl√© par d√©faut utilis√©e');
                    this.showConfigurationError('Cl√© API manquante ou cl√© par d√©faut utilis√©e');
                    return false;
                }

                if (!this.apiRegion || !this.apiPlatform) {
                    console.error('‚ùå R√©gion ou plateforme manquante');
                    this.showConfigurationError('R√©gion ou plateforme manquante');
                    return false;
                }

                console.log('‚úÖ Configuration valid√©e');
                this.resetDisplayStyle();
                return true;
            }

            showConfigurationError(message) {
                console.error('‚ùå Erreur de configuration:', message);

                const rankIcon = document.getElementById('rankIcon');
                const rrDisplay = document.getElementById('rrDisplay');

                rankIcon.innerHTML = '<div style="color: #ff0000; font-size: 12px; text-align: center;">‚ùå<br>Config<br>Error</div>';

                rrDisplay.textContent = message;
                rrDisplay.style.color = '#ff0000';

                const leaderboardPosition = document.getElementById('leaderboardPosition');
                if (leaderboardPosition) {
                    leaderboardPosition.style.display = 'none';
                }
            }

            resetDisplayStyle() {
                const rrDisplay = document.getElementById('rrDisplay');
                if (rrDisplay) {
                    rrDisplay.style.color = '#ffffff';
                }
            }

            setupURLChangeDetection() {
                console.log('üîç Configuration de la d√©tection des changements d\'URL...');

                let currentURL = window.location.href;

                setInterval(() => {
                    if (window.location.href !== currentURL) {
                        console.log('üîÑ Changement d\'URL d√©tect√©, rechargement de la configuration...');
                        currentURL = window.location.href;
                        this.reloadConfiguration();
                    }
                }, 1000);

                console.log('‚úÖ D√©tection des changements d\'URL configur√©e');
            }

            applyFont(fontName) {
                if (!fontName) fontName = 'Arial';

                const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];

                let fontFamily;
                if (systemFonts.includes(fontName)) {
                    fontFamily = fontName;
                } else {
                    fontFamily = `'${fontName}'`;
                }

                document.documentElement.style.setProperty('--custom-font', `${fontFamily}, sans-serif`);

                document.body.style.fontFamily = `${fontFamily}, sans-serif`;

                console.log(`üî§ Police appliqu√©e: ${fontName} (${fontFamily})`);
            }

            startPreviewCycle() {
                if (this.previewIntervalId) {
                    clearTimeout(this.previewIntervalId);
                    clearInterval(this.previewIntervalId);
                }

                console.log(`üîÑ D√©marrage du cycle preview avec intervalle de ${this.updateInterval}ms`);

                const cycleWithDelay = async () => {
                    while (this.isAnimating || this.isPositionAnimating) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    await this.cyclePreviewState();

                    while (this.isAnimating || this.isPositionAnimating) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    this.previewIntervalId = setTimeout(cycleWithDelay, this.updateInterval);
                };

                this.previewIntervalId = setTimeout(cycleWithDelay, this.updateInterval);
            }
            async loadRealData() {
                console.log('üì° Chargement des vraies donn√©es depuis l\'API...');

                this.clearOldCachedData();

                this.currentRankData = {
                    rank: 'Loading...',
                    rr: 0,
                    tier: 0
                };
                this.currentLeaderboardData = null;

                this.clearDisplay();

                await this.loadRankData();
                await this.loadLeaderboardData();

                this.displayCurrentRank();
                this.displayLeaderboardPosition();

                console.log('üß™ R√©cup√©ration des donn√©es depuis l\'API...');
                await this.fetchBothAPIs();

                if (this.updateInterval > 0) {
                    if (this.realDataIntervalId) {
                        clearInterval(this.realDataIntervalId);
                    }
                    this.realDataIntervalId = setInterval(async () => {
                        await this.fetchBothAPIs();
                    }, this.updateInterval);
                    console.log(`üîÑ Rafra√Æchissement automatique configur√© toutes les ${this.updateInterval}ms`);
                }
            }

            reloadConfiguration() {
                console.log('üîÑ Rechargement de la configuration depuis les param√®tres URL...');

                const urlParams = new URLSearchParams(window.location.search);

                const oldPlayerName = this.playerName;
                const oldPlayerTag = this.playerTag;
                const oldIsPreviewMode = this.isPreviewMode;

                this.playerName = urlParams.get('name') || this.playerName;
                this.playerTag = urlParams.get('tag') || this.playerTag;

                const apiKeyParam = urlParams.get('api_key');
                const regionParam = urlParams.get('region');
                const platformParam = urlParams.get('platform');

                if (apiKeyParam) this.apiKey = apiKeyParam;
                if (regionParam) this.apiRegion = regionParam;
                if (platformParam) this.apiPlatform = platformParam;

                const hasAllInfo = this.playerName &&
                                   this.playerName !== 'username' &&
                                   this.playerTag &&
                                   this.playerTag !== 'tags' &&
                                   apiKeyParam &&
                                   apiKeyParam !== 'api_key' &&
                                   apiKeyParam.trim() !== '' &&
                                   regionParam &&
                                   regionParam !== 'region' &&
                                   regionParam.trim() !== '' &&
                                   platformParam &&
                                   platformParam !== 'plateforme' &&
                                   platformParam.trim() !== '';

                console.log('üîç D√©tection des informations (reload):', {
                    playerName: this.playerName,
                    playerTag: this.playerTag,
                    apiKey: apiKeyParam ? 'pr√©sent' : 'manquant',
                    region: regionParam ? 'pr√©sent' : 'manquant',
                    platform: platformParam ? 'pr√©sent' : 'manquant',
                    hasAllInfo: hasAllInfo
                });

                this.isPreviewMode = !hasAllInfo;

                if (oldIsPreviewMode && !this.isPreviewMode) {
                    console.log('üîÑ Passage du mode preview au mode r√©el - chargement des vraies donn√©es...');
                    if (this.previewIntervalId) {
                        clearInterval(this.previewIntervalId);
                        this.previewIntervalId = null;
                    }
                    if (!urlParams.get('update_interval')) {
                        this.updateInterval = 60000;
                    }
                    this.loadRealData();
                    return;
                }

                if (!oldIsPreviewMode && this.isPreviewMode) {
                    console.log('üîÑ Passage du mode r√©el au mode preview - activation du cycle...');
                    if (this.realDataIntervalId) {
                        clearInterval(this.realDataIntervalId);
                        this.realDataIntervalId = null;
                    }
                    this.previewStateIndex = 0;
                    this.previewStates = [
                        {
                            rank: 'Ascendant 3',
                            rr: 67,
                            tier: 23,
                            leaderboard: null
                        },
                        {
                            rank: 'Immortal 1',
                            rr: 67,
                            tier: 24,
                            leaderboard: 1111
                        }
                    ];
                    this.startPreviewCycle();
                }

                const newInterval = urlParams.get('update_interval');
                if (newInterval) {
                    const oldInterval = this.updateInterval;
                    this.updateInterval = parseInt(newInterval) || this.updateInterval;

                    if (this.isPreviewMode && oldInterval !== this.updateInterval) {
                        console.log(`üîÑ Intervalle chang√© de ${oldInterval}ms √† ${this.updateInterval}ms, red√©marrage du cycle...`);
                        if (this.previewIntervalId) {
                            clearTimeout(this.previewIntervalId);
                            clearInterval(this.previewIntervalId);
                            this.previewIntervalId = null;
                        }
                        this.startPreviewCycle();
                    }

                    if (!this.isPreviewMode && oldInterval !== this.updateInterval && this.realDataIntervalId) {
                        console.log(`üîÑ Intervalle chang√© de ${oldInterval}ms √† ${this.updateInterval}ms, red√©marrage du rafra√Æchissement...`);
                        clearInterval(this.realDataIntervalId);
                        this.realDataIntervalId = setInterval(async () => {
                            await this.fetchBothAPIs();
                        }, this.updateInterval);
                    }
                }

                const newFont = urlParams.get('font') || 'Arial';
                this.applyFont(newFont);

                this.twitchChannel = urlParams.get('channel') || this.twitchChannel;
                this.twitchNick = urlParams.get('nick') || this.twitchNick;
                this.twitchPass = urlParams.get('pass') || this.twitchPass;

                const newModerators = this.parseUserList(urlParams.get('moderators'));
                const newVips = this.parseUserList(urlParams.get('vips'));
                const newBlacklist = this.parseUserList(urlParams.get('blacklist'));

                if (newModerators.length > 0) this.moderators = newModerators;
                if (newVips.length > 0) this.vips = newVips;
                if (newBlacklist.length > 0) this.blacklist = newBlacklist;

                this.logConfiguration();

                if (oldPlayerName !== this.playerName || oldPlayerTag !== this.playerTag) {
                    console.log('üîÑ Joueur chang√©, for√ßage de la mise √† jour des donn√©es...');
                    this.forceRefreshData();
                }

                console.log('‚úÖ Configuration recharg√©e avec succ√®s!');
            }

            generateConfigURL() {
                const params = new URLSearchParams();

                params.set('name', this.playerName);
                params.set('tag', this.playerTag);
                params.set('api_key', this.apiKey);
                params.set('region', this.apiRegion);
                params.set('platform', this.apiPlatform);
                params.set('update_interval', this.updateInterval.toString());
                params.set('channel', this.twitchChannel);
                params.set('nick', this.twitchNick);
                params.set('pass', this.twitchPass);

                if (this.moderators.length > 0) {
                    params.set('moderators', this.moderators.join(','));
                }
                if (this.vips.length > 0) {
                    params.set('vips', this.vips.join(','));
                }
                if (this.blacklist.length > 0) {
                    params.set('blacklist', this.blacklist.join(','));
                }

                const configURL = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
                console.log('üîó URL de configuration g√©n√©r√©e:', configURL);
                return configURL;
            }

            updateUserLists(newModerators = null, newVips = null, newBlacklist = null) {
                if (newModerators) {
                    this.moderators = newModerators.map(u => u.toLowerCase());
                    console.log('üìù Liste des mod√©rateurs mise √† jour:', this.moderators);
                }

                if (newVips) {
                    this.vips = newVips.map(u => u.toLowerCase());
                    console.log('üìù Liste des VIPs mise √† jour:', this.vips);
                }

                if (newBlacklist) {
                    this.blacklist = newBlacklist.map(u => u.toLowerCase());
                    console.log('üìù Blacklist mise √† jour:', this.blacklist);
                }
            }

            addModerator(username) {
                if (!this.moderators.includes(username.toLowerCase())) {
                    this.moderators.push(username.toLowerCase());
                    console.log(`‚úÖ ${username} ajout√© aux mod√©rateurs`);
                }
            }

            testCommandPermissions(username) {
                console.log(`üß™ Test des permissions pour: ${username}`);
                console.log(`   üëÆ Mod√©rateur: ${this.moderators.includes(username.toLowerCase())}`);
                console.log(`   üëë VIP: ${this.vips.includes(username.toLowerCase())}`);
                console.log(`   üö´ Blacklist√©: ${this.blacklist.includes(username.toLowerCase())}`);
                console.log(`   ‚úÖ Peut utiliser les commandes: ${this.hasPermission(username)}`);
            }

            testRefreshRank() {
                console.log('üß™ Test de refresh manuel - Rechargement de la page...');
                this.executePageReload();
            }

            executePageReload() {
                console.log('üîÑ Rechargement forc√© de la page...');

                window.location.reload();
            }

            removeModerator(username) {
                const index = this.moderators.indexOf(username.toLowerCase());
                if (index > -1) {
                    this.moderators.splice(index, 1);
                    console.log(`‚ùå ${username} retir√© des mod√©rateurs`);
                }
            }

            addVIP(username) {
                if (!this.vips.includes(username.toLowerCase())) {
                    this.vips.push(username.toLowerCase());
                    console.log(`‚úÖ ${username} ajout√© aux VIPs`);
                }
            }

            removeVIP(username) {
                const index = this.vips.indexOf(username.toLowerCase());
                if (index > -1) {
                    this.vips.splice(index, 1);
                    console.log(`‚ùå ${username} retir√© des VIPs`);
                }
            }

            addToBlacklist(username) {
                if (!this.blacklist.includes(username.toLowerCase())) {
                    this.blacklist.push(username.toLowerCase());
                    console.log(`üö´ ${username} ajout√© √† la blacklist`);
                }
            }

            removeFromBlacklist(username) {
                const index = this.blacklist.indexOf(username.toLowerCase());
                if (index > -1) {
                    this.blacklist.splice(index, 1);
                    console.log(`‚úÖ ${username} retir√© de la blacklist`);
                }
            }

            hasPermission(username, userTags) {
                if (this.blacklist.includes(username.toLowerCase())) {
                    console.log(`üö´ Utilisateur ${username} est dans la blacklist`);
                    return false;
                }

                if (this.moderators.includes(username.toLowerCase())) {
                    console.log(`‚úÖ ${username} est mod√©rateur`);
                    return true;
                }

                if (this.vips.includes(username.toLowerCase())) {
                    console.log(`‚úÖ ${username} est VIP`);
                    return true;
                }

                if (userTags) {
                    if (userTags.includes('moderator=1') || userTags.includes('vip=1')) {
                        console.log(`‚úÖ ${username} a les permissions via tags Twitch`);
                        return true;
                    }
                }

                console.log(`‚ùå ${username} n'a pas les permissions`);
                return false;
            }

            showOverlay() {
                if (!this.isOverlayVisible) {
                    this.isOverlayVisible = true;
                    document.body.classList.remove('hidden');
                    console.log('üëÅÔ∏è Overlay affich√© via commande');
                }
            }

            hideOverlay() {
                if (this.isOverlayVisible) {
                    this.isOverlayVisible = false;
                    document.body.classList.add('hidden');
                    console.log('üôà Overlay masqu√© via commande');
                }
            }

            showCommandFeedback(message, type = 'success') {
                const feedback = document.getElementById('commandFeedback');
                feedback.textContent = message;
                feedback.className = `command-feedback ${type}`;

                setTimeout(() => {
                    feedback.classList.add('show');
                }, 100);

                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 3000);
            }

            parseChatCommand(username, message, userTags) {
                const command = message.trim().toLowerCase();

                if (command === '!showrank') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üéÆ Commande !showrank re√ßue de ${username}`);
                        this.showOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !showrank sans permission`);
                    }
                    return;
                }

                if (command === '!hiderank') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üéÆ Commande !hiderank re√ßue de ${username}`);
                        this.hideOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !hiderank sans permission`);
                    }
                    return;
                }

                                if (command === '!refreshrank' || command === '!rankreload') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üîÑ Commande ${command} re√ßue de ${username} - Rechargement forc√© de la page...`);

                        this.executePageReload();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser ${command} sans permission`);
                    }
                    return;
                }

                if (command.startsWith('!')) {
                    console.log(`‚ùì Commande inconnue re√ßue de ${username}: ${command}`);
                }
            }

            async init() {
                const modeText = this.isPreviewMode ? 'Preview Mode' : 'Real Mode';
                console.log(`üéÆ Initialisation du widget Valorant (${modeText})...`);
                console.log(`üë§ Joueur: ${this.playerName}#${this.playerTag}`);

                this.resetDisplayStyle();
                this.displayCurrentRank();
                this.displayLeaderboardPosition();

                if (this.isPreviewMode) {
                    console.log('üîÑ Mode preview activ√© - cycle entre les √©tats...');
                    this.startPreviewCycle();
                } else {
                    console.log('üëë Mod√©rateurs:', this.moderators);
                    console.log('‚≠ê VIPs:', this.vips);
                    console.log('üö´ Blacklist:', this.blacklist);

                    this.clearOldCachedData();

                    await this.loadRankData();
                    await this.loadLeaderboardData();

                    this.displayCurrentRank();
                    this.displayLeaderboardPosition();

                    console.log('üß™ Test des APIs en cours...');
                    await this.fetchBothAPIs();

                    console.log('üîÑ For√ßage de la mise √† jour des donn√©es pour la nouvelle configuration...');
                    await this.forceRefreshData();

                    if (this.updateInterval > 0) {
                        if (this.realDataIntervalId) {
                            clearInterval(this.realDataIntervalId);
                        }
                        this.realDataIntervalId = setInterval(async () => {
                            await this.fetchBothAPIs();
                        }, this.updateInterval);
                        console.log(`üîÑ Rafra√Æchissement automatique configur√© toutes les ${this.updateInterval}ms`);
                    }

                    this.connectToTwitchChat();

                    setInterval(() => {
                        if (!this.isAnimating && !this.isPositionAnimating) {
                            this.displayCurrentRank();
                            this.displayLeaderboardPosition();
                        }
                    }, 30000);
                }
            }

            async cyclePreviewState() {
                this.previewStateIndex = (this.previewStateIndex + 1) % this.previewStates.length;
                const newState = this.previewStates[this.previewStateIndex];

                const oldRR = this.currentRankData.rr;
                const oldTier = this.currentRankData.tier;
                const oldPosition = this.currentLeaderboardData ? this.currentLeaderboardData.leaderboard_rank : null;

                this.currentRankData = {
                    rank: newState.rank,
                    rr: newState.rr,
                    tier: newState.tier
                };

                this.currentLeaderboardData = newState.leaderboard ? {
                    leaderboard_rank: newState.leaderboard,
                    estimated: false
                } : null;

                if (oldTier !== newState.tier || oldRR !== newState.rr) {
                    await this.animateRRChange(oldRR, newState.rr, oldTier, newState.tier, newState.rr - oldRR);
                    if (oldTier !== newState.tier) {
                        this.updateRankImage();
                    }
                } else {
                    this.displayCurrentRank();
                }

                if (oldPosition !== (newState.leaderboard || null)) {
                    if (oldPosition !== null && newState.leaderboard !== null) {
                        await this.animatePositionChange(oldPosition, newState.leaderboard);
                    } else {
                        this.displayLeaderboardPosition();
                    }
                } else {
                    this.displayLeaderboardPosition();
                }

                this.previousRR = newState.rr;
                this.previousPosition = newState.leaderboard;

                console.log(`üîÑ Preview: Changement vers ${newState.rank} ${newState.rr} RR${newState.leaderboard ? ` (Leaderboard #${newState.leaderboard})` : ''}`);
            }

            async loadRankData() {
                try {
                    // Check if we have cached data for the current player
                    const savedData = localStorage.getItem(`valorant-rank-data-${this.playerName}-${this.playerTag}`);
                    if (savedData) {
                        const loadedData = JSON.parse(savedData);
                        this.currentRankData = {
                            rank: loadedData.rank,
                            rr: loadedData.rr,
                            tier: loadedData.tier
                        };
                        this.previousRR = loadedData.rr;
                        this.lastChange = loadedData.lastChange || null;
                        console.log('‚úÖ Donn√©es de rang charg√©es depuis localStorage pour', this.playerName, this.playerTag, ':', this.currentRankData);
                        return true;
                    } else {
                        console.log('üìÑ Aucune donn√©e sauvegard√©e trouv√©e pour', this.playerName, this.playerTag, ', utilisation des donn√©es par d√©faut temporaires');
                        this.previousRR = this.currentRankData.rr;
                        return false;
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger les donn√©es sauvegard√©es, utilisation des donn√©es par d√©faut temporaires');
                    this.previousRR = this.currentRankData.rr;
                    return false;
                }
            }

            async saveRankData() {
                try {
                    const dataToSave = {
                        rank: this.currentRankData.rank,
                        rr: this.currentRankData.rr,
                        tier: this.currentRankData.tier,
                        lastChange: this.lastChange,
                        lastUpdated: new Date().toISOString()
                    };

                    localStorage.setItem(`valorant-rank-data-${this.playerName}-${this.playerTag}`, JSON.stringify(dataToSave));

                    console.log('üíæ Donn√©es de rang sauvegard√©es dans localStorage:', dataToSave);
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde:', error);
                }
            }

            async loadLeaderboardData() {
                try {
                    const savedData = localStorage.getItem(`valorant-leaderboard-${this.playerName}-${this.playerTag}`);
                    if (savedData) {
                        const loadedData = JSON.parse(savedData);

                        if (this.currentRankData && this.currentRankData.tier < 24) {
                            console.log(`‚ùå Rang trop bas pour le leaderboard (tier ${this.currentRankData.tier}), suppression des anciennes donn√©es`);
                            this.currentLeaderboardData = null;
                            this.displayLeaderboardPosition();
                            return false;
                        }

                        this.currentLeaderboardData = loadedData.playerData;
                        this.previousPosition = loadedData.position;
                        console.log('‚úÖ Donn√©es du leaderboard charg√©es depuis localStorage pour', this.playerName, this.playerTag, ':', this.currentLeaderboardData);
                        return true;
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger les donn√©es du leaderboard sauvegard√©es pour', this.playerName, this.playerTag);
                }
                return false;
            }

            async saveLeaderboardData() {
                try {
                    const dataToSave = {
                        playerData: this.currentLeaderboardData,
                        position: this.currentLeaderboardData ? this.currentLeaderboardData.leaderboard_rank : null,
                        lastUpdated: new Date().toISOString()
                    };

                    localStorage.setItem(`valorant-leaderboard-${this.playerName}-${this.playerTag}`, JSON.stringify(dataToSave));
                    console.log('üíæ Donn√©es du leaderboard sauvegard√©es');
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde du leaderboard:', error);
                }
            }

            connectToTwitchChat() {
                console.log('üîó Connexion au chat Twitch pour √©couter les commandes...');

                // Connexion WebSocket au chat IRC de Twitch
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('‚úÖ Connect√© au chat Twitch de fugu_fps');
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                                    socket.send(`PASS ${this.twitchPass}`);
                socket.send(`NICK ${this.twitchNick}`);
                    socket.send(`JOIN #${this.twitchChannel}`);
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    this.parseChatMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('‚ùå Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('üîå Connexion au chat Twitch ferm√©e');
                    setTimeout(() => {
                        console.log('üîÑ Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 10000);
                };
            }

            parseChatMessage(rawMessage) {
                try {
                    if (!rawMessage.includes(`PRIVMSG #${this.twitchChannel} :`)) {
                        return;
                    }

                    const tagsMatch = rawMessage.match(/@([^ ]+) /);
                    let userTags = '';
                    if (tagsMatch) {
                        userTags = tagsMatch[1];
                    }

                    const userMatch = rawMessage.match(/:([^!]+)!/);
                    if (!userMatch) return;
                    const username = userMatch[1].toLowerCase();

                    const messageMatch = rawMessage.match(new RegExp(`PRIVMSG #${this.twitchChannel} :(.+)`));
                    if (!messageMatch) return;
                    const messageContent = messageMatch[1].trim();

                    console.log(`üí¨ Message de ${username}: ${messageContent}`);

                    if (messageContent.startsWith('!')) {
                        this.parseChatCommand(username, messageContent, userTags);
                    }

                } catch (error) {
                    console.error('‚ùå Erreur lors du parsing du message:', error);
                }
            }

            updateRankImage() {
                const rankIcon = document.getElementById('rankIcon');
                const data = this.currentRankData;

                const rankImagePath = this.rankImages[data.tier];
                if (rankImagePath) {
                    rankIcon.innerHTML = `<img src="${rankImagePath}" alt="${data.rank}">`;
                    console.log(`üñºÔ∏è Image de rang mise √† jour instantan√©ment: ${rankImagePath} (${data.rank})`);
                } else {
                    rankIcon.innerHTML = `<div>${data.rank}</div>`;
                    console.log(`‚ö†Ô∏è Pas d'image trouv√©e pour le rang ${data.tier} (${data.rank})`);
                }
            }

            displayCurrentRank() {
                const rrDisplay = document.getElementById('rrDisplay');
                const rankIcon = document.getElementById('rankIcon');

                const data = this.currentRankData;

                const rankImagePath = this.rankImages[data.tier];
                if (rankImagePath) {
                    rankIcon.innerHTML = `<img src="${rankImagePath}" alt="${data.rank}">`;
                    console.log(`üñºÔ∏è Image de rang charg√©e: ${rankImagePath}`);
                } else {
                    rankIcon.innerHTML = `<div>${data.rank}</div>`;
                    console.log(`‚ö†Ô∏è Pas d'image trouv√©e pour le rang ${data.tier}`);
                }

                if (!this.isAnimating) {
                    rrDisplay.textContent = `${data.rr} RR`;
                }

                console.log(`‚úÖ Affichage mis √† jour: ${data.rank} - ${data.rr} RR`);
            }

            async animateRRChange(oldRR, newRR, oldTier, newTier, changeValue = null) {
                if (this.isAnimating) return;
                this.isAnimating = true;

                const rrDisplay = document.getElementById('rrDisplay');

                if (changeValue !== null && changeValue !== this.lastChange) {
                    this.showChangeIndicator(changeValue);
                    this.lastChange = changeValue;
                }

                if (oldTier !== newTier) {
                    const stepDelay = 50;

                    const isAscending = newTier > oldTier;

                    if (isAscending) {
                        for (let rr = oldRR; rr <= 99; rr++) {
                            rrDisplay.textContent = `${rr} RR`;
                            await new Promise(resolve => setTimeout(resolve, stepDelay));
                        }

                        this.updateRankImage();

                        for (let rr = 0; rr <= newRR; rr++) {
                            rrDisplay.textContent = `${rr} RR`;
                            await new Promise(resolve => setTimeout(resolve, stepDelay));
                        }
                    } else {
                        for (let rr = oldRR; rr >= 0; rr--) {
                            rrDisplay.textContent = `${rr} RR`;
                            await new Promise(resolve => setTimeout(resolve, stepDelay));
                        }

                        this.updateRankImage();

                        for (let rr = 99; rr >= newRR; rr--) {
                            rrDisplay.textContent = `${rr} RR`;
                            await new Promise(resolve => setTimeout(resolve, stepDelay));
                        }
                    }
                } else {
                    const difference = newRR - oldRR;
                    const steps = Math.min(Math.abs(difference), 50);
                    const stepSize = difference / steps;
                    const stepDelay = 30;

                    for (let i = 0; i <= steps; i++) {
                        const currentRR = Math.round(oldRR + (stepSize * i));
                        rrDisplay.textContent = `${currentRR} RR`;

                        if (i < steps) {
                            await new Promise(resolve => setTimeout(resolve, stepDelay));
                        }
                    }
                }

                this.isAnimating = false;
            }

            displayLeaderboardPosition() {
                const leaderboardElement = document.getElementById('leaderboardPosition');

                if (!this.showLeaderboard) {
                    leaderboardElement.style.display = 'none';
                    console.log('üèÜ Leaderboard masqu√© (show_leaderboard=false)');
                    return;
                }

                if (!this.currentLeaderboardData) {
                    leaderboardElement.style.display = 'none';
                    return;
                }

                leaderboardElement.style.display = 'block';

                if (!this.isPositionAnimating) {
                    const prefix = this.currentLeaderboardData.estimated ? '~#' : '#';
                    leaderboardElement.textContent = `${prefix}${this.currentLeaderboardData.leaderboard_rank.toLocaleString()}`;
                }

                const estimatedText = this.currentLeaderboardData.estimated ? ' (estim√©)' : '';
                console.log(`‚úÖ Position leaderboard affich√©e: ~#${this.currentLeaderboardData.leaderboard_rank}${estimatedText}`);
            }

            async animatePositionChange(oldPosition, newPosition) {
                if (this.isPositionAnimating) return;
                this.isPositionAnimating = true;

                const leaderboardElement = document.getElementById('leaderboardPosition');
                if (!leaderboardElement) {
                    this.isPositionAnimating = false;
                    return;
                }

                const existingIndicator = leaderboardElement.querySelector('.position-change');
                if (existingIndicator) {
                    existingIndicator.remove();
                }

                const change = oldPosition - newPosition;
                const changeElement = document.createElement('div');

                if (change > 0) {
                    changeElement.className = 'position-change up';
                    changeElement.textContent = `‚Üë${change}`;
                } else {
                    changeElement.className = 'position-change down';
                    changeElement.textContent = `‚Üì${Math.abs(change)}`;
                }

                leaderboardElement.appendChild(changeElement);

                const difference = newPosition - oldPosition;
                const steps = Math.min(Math.abs(difference), 100);
                const stepSize = difference / steps;
                const stepDelay = 20;

                const originalText = leaderboardElement.textContent;

                for (let i = 0; i <= steps; i++) {
                    const currentPosition = Math.round(oldPosition + (stepSize * i));
                    leaderboardElement.innerHTML = `#${currentPosition}`;
                    leaderboardElement.appendChild(changeElement);

                    if (i < steps) {
                        await new Promise(resolve => setTimeout(resolve, stepDelay));
                    }
                }

                setTimeout(() => {
                    if (changeElement.parentNode) {
                        changeElement.remove();
                    }
                }, 3000);

                this.isPositionAnimating = false;
                console.log(`üìà Changement de position: #${oldPosition} ‚Üí #${newPosition} (${change > 0 ? '+' : ''}${change})`);
            }

            async animatePositionChange_OLD(oldPosition, newPosition) {
                if (this.isPositionAnimating) return;
                this.isPositionAnimating = true;

                const leaderboardElement = document.getElementById('leaderboardPosition');

                const difference = newPosition - oldPosition;
                const steps = Math.min(Math.abs(difference), 100);
                const stepSize = difference / steps;
                const stepDelay = 20;

                console.log(`üé¨ Animating position from ${oldPosition} to ${newPosition} in ${steps} steps`);

                for (let i = 0; i <= steps; i++) {
                    const currentPosition = Math.round(oldPosition + (stepSize * i));
                    const prefix = this.currentLeaderboardData && this.currentLeaderboardData.estimated ? '~#' : '#';
                    leaderboardElement.textContent = `${prefix}${currentPosition.toLocaleString()}`;

                    if (i < steps) {
                        await new Promise(resolve => setTimeout(resolve, stepDelay));
                    }
                }

                this.showPositionChangeIndicator(oldPosition, newPosition);

                this.isPositionAnimating = false;
            }

            showPositionChangeIndicator(oldPosition, newPosition) {
                const leaderboardElement = document.getElementById('leaderboardPosition');

                const existingIndicator = leaderboardElement.querySelector('.position-change');
                if (existingIndicator) {
                    existingIndicator.remove();
                }

                const change = oldPosition - newPosition;
                const changeElement = document.createElement('div');

                if (change > 0) {
                    changeElement.className = 'position-change up';
                    changeElement.textContent = `‚Üë${change}`;
                } else {
                    changeElement.className = 'position-change down';
                    changeElement.textContent = `‚Üì${Math.abs(change)}`;
                }

                leaderboardElement.appendChild(changeElement);

                setTimeout(() => {
                    if (changeElement.parentNode) {
                        changeElement.remove();
                    }
                }, 3000);

                console.log(`üìà Changement de position: #${oldPosition} ‚Üí #${newPosition} (${change > 0 ? '+' : ''}${change})`);
            }

            async fetchBothAPIs() {
                console.log('üîÑ D√©but de la mise √† jour des deux APIs...');

                await this.fetchRealRankData();

                if (!this.showLeaderboard) {
                    console.log('üèÜ R√©cup√©ration du leaderboard d√©sactiv√©e (show_leaderboard=false)');
                    this.currentLeaderboardData = null;
                    this.displayLeaderboardPosition();
                    return;
                }

                if (this.currentRankData && this.currentRankData.tier < 24) {
                    console.log(`‚ùå Rang trop bas pour le leaderboard (tier ${this.currentRankData.tier}), pas besoin de chercher dans le leaderboard`);
                    this.currentLeaderboardData = null;
                    this.displayLeaderboardPosition();
                    return;
                }

                setTimeout(async () => {
                    await this.fetchLeaderboardData();
                }, 2000);
            }

            async fetchLeaderboardData() {
                try {
                    console.log('üèÜ D√©but de la recherche dans le leaderboard...');

                    const currentTier = this.currentRankData.tier;
                    if (currentTier < 24) {
                        console.log(`‚ùå Rang trop bas pour le leaderboard (tier ${currentTier}), minimum Immortal 1 (tier 24)`);
                        this.currentLeaderboardData = null;
                        this.displayLeaderboardPosition();
                        return;
                    }

                    const apiUrl = `https://api.henrikdev.xyz/valorant/v3/leaderboard/${this.apiRegion}/${this.apiPlatform}?size=15000&api_key=${this.apiKey}`;
                    console.log('üåê URL API Leaderboard:', apiUrl);

                    console.log('üì° Envoi de la requ√™te vers l\'API Leaderboard...');
                    const response = await fetch(apiUrl);

                    console.log('üìã Statut de la r√©ponse Leaderboard:', response.status, response.statusText);

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status} - ${response.statusText}`);
                    }

                    console.log('üì¶ Parsing du JSON Leaderboard...');
                    const json = await response.json();
                    console.log('üìÑ R√©ponse de l\'API Leaderboard re√ßue, calcul de la position approximative...');

                    if (!json.data || !json.data.players || !Array.isArray(json.data.players)) {
                        throw new Error('Format de donn√©es invalide re√ßu de l\'API Leaderboard');
                    }

                    const currentRR = this.currentRankData.rr;

                    console.log(`üîç Estimation de la position pour ${currentRR} RR (tier ${currentTier})...`);

                    let estimatedPosition = this.estimatePositionFromRR(json.data.players, currentRR, currentTier);

                    if (!estimatedPosition) {
                        console.log(`‚ùå Impossible d'estimer la position pour ${currentRR} RR`);
                        this.currentLeaderboardData = null;
                        this.displayLeaderboardPosition();
                        return;
                    }

                    console.log(`üéØ Position estim√©e: ~#${estimatedPosition} pour ${currentRR} RR`);

                    const estimatedLeaderboardData = {
                        leaderboard_rank: estimatedPosition,
                        rr: currentRR,
                        tier: currentTier,
                        name: this.playerName,
                        tag: this.playerTag,
                        estimated: true
                    };

                    const oldPosition = this.currentLeaderboardData ? this.currentLeaderboardData.leaderboard_rank : null;
                    const newPosition = estimatedPosition;

                    this.currentLeaderboardData = estimatedLeaderboardData;

                    if (oldPosition !== null && oldPosition !== newPosition) {
                        console.log(`üé¨ Animation position leaderboard: ${oldPosition} ‚Üí ~${newPosition}`);
                        await this.animatePositionChange(oldPosition, newPosition);
                    } else {
                        this.displayLeaderboardPosition();
                    }

                    this.previousPosition = newPosition;
                    await this.saveLeaderboardData();

                    console.log('üéâ Mise √† jour du leaderboard (estim√©) termin√©e avec succ√®s!');

                } catch (error) {
                    console.error('‚ùå Erreur dans fetchLeaderboardData:', error);
                    this.currentLeaderboardData = null;
                    this.displayLeaderboardPosition();
                }
            }            estimatePositionFromRR(players, targetRR, targetTier) {
                console.log(`üîç Debug: Recherche pour ${targetRR} RR exact (tier ${targetTier})`);

                const relevantPlayers = players.filter(player => {
                    if (player.tier === targetTier) {
                        return player.rr >= targetRR;
                    }
                    return player.tier > targetTier;
                });

                console.log(`üîç Debug: ${relevantPlayers.length} joueurs trouv√©s avec RR >= ${targetRR} ou tier sup√©rieur`);

                const playersWithHigherRR = players.filter(player => {
                    if (player.tier === targetTier) {
                        return player.rr > targetRR;
                    }
                    return player.tier > targetTier;
                });

                if (playersWithHigherRR.length >= players.length) {
                    console.log(`‚ùå Debug: Tous les ${players.length} joueurs du leaderboard ont un RR strictement sup√©rieur`);
                    console.log(`‚ùå Debug: Le joueur avec ${targetRR} RR n'est pas dans le top ${players.length}`);
                    return null;
                }

                if (relevantPlayers.length > 0) {
                    const bestPosition = Math.min(...relevantPlayers.map(player => player.leaderboard_rank));

                    const playersWithExactSameRR = relevantPlayers.filter(player =>
                        player.tier === targetTier && player.rr === targetRR
                    );

                    console.log(`üîç Debug: ${playersWithExactSameRR.length} joueurs avec exactement ${targetRR} RR`);

                    if (playersWithExactSameRR.length > 0) {
                        const positions = playersWithExactSameRR.map(player => player.leaderboard_rank).sort((a, b) => a - b);
                        const highestRank = positions[0];
                        const lowestRank = positions[positions.length - 1];
                        const middlePosition = Math.round((highestRank + lowestRank) / 2);

                        console.log(`üéØ Debug: ${playersWithExactSameRR.length} joueurs avec ${targetRR} RR - Positions: #${highestRank} √† #${lowestRank}`);
                        console.log(`üéØ Debug: Position du milieu calcul√©e: #${middlePosition}`);
                        return middlePosition;
                    } else {
                        const playersAhead = relevantPlayers.length;
                        const estimatedPosition = playersAhead + 1;

                        if (estimatedPosition > players.length) {
                            console.log(`‚ùå Debug: Position estim√©e ${estimatedPosition} > taille leaderboard ${players.length}`);
                            return null;
                        }

                        console.log(`üéØ Debug: Position estim√©e bas√©e sur ${playersAhead} joueurs devant: #${estimatedPosition}`);
                        return estimatedPosition;
                    }
                }

                const sameTierPlayers = players.filter(player => player.tier === targetTier);
                console.log(`üîç Debug: ${sameTierPlayers.length} joueurs dans le m√™me tier ${targetTier}`);

                if (sameTierPlayers.length > 0) {
                    sameTierPlayers.sort((a, b) => {
                        if (b.rr !== a.rr) return b.rr - a.rr;
                        return a.leaderboard_rank - b.leaderboard_rank;
                    });

                    console.log(`üîç Debug: Premiers joueurs du tier:`, sameTierPlayers.slice(0, 5).map(p => `${p.rr}RR #${p.leaderboard_rank}`));
                    console.log(`üîç Debug: Derniers joueurs du tier:`, sameTierPlayers.slice(-5).map(p => `${p.rr}RR #${p.leaderboard_rank}`));

                    for (let i = 0; i < sameTierPlayers.length; i++) {
                        if (targetRR >= sameTierPlayers[i].rr) {
                            if (targetRR === sameTierPlayers[i].rr) {
                                const sameRRPlayers = sameTierPlayers.filter(p => p.rr === targetRR);
                                const positions = sameRRPlayers.map(p => p.leaderboard_rank).sort((a, b) => a - b);
                                const highestRank = positions[0];
                                const lowestRank = positions[positions.length - 1];
                                const middlePosition = Math.round((highestRank + lowestRank) / 2);

                                console.log(`üéØ Debug: ${sameRRPlayers.length} joueurs avec ${targetRR} RR - Positions: #${highestRank} √† #${lowestRank}`);
                                console.log(`üéØ Debug: Position du milieu pour RR identique: #${middlePosition}`);
                                return middlePosition;
                            } else {
                                const position = Math.max(1, sameTierPlayers[i].leaderboard_rank - 1);
                                console.log(`üéØ Debug: Position estim√©e avant joueur avec ${sameTierPlayers[i].rr}RR: #${position}`);
                                return position;
                            }
                        }
                    }

                    const lastPlayer = sameTierPlayers[sameTierPlayers.length - 1];
                    const worstPosition = lastPlayer.leaderboard_rank;

                    if (worstPosition >= players.length - 100) {
                        console.log(`‚ùå Debug: RR ${targetRR} trop bas, dernier joueur tier ${targetTier} d√©j√† en position ${worstPosition}/${players.length}`);
                        return null;
                    }

                    const position = worstPosition + Math.max(10, (lastPlayer.rr - targetRR) * 10);
                    if (position > players.length) {
                        console.log(`‚ùå Debug: Position estim√©e ${position} > taille leaderboard ${players.length}`);
                        return null;
                    }

                    console.log(`üéØ Debug: Position estim√©e apr√®s dernier joueur (${lastPlayer.rr}RR): #${position}`);
                    return position;
                }

                console.log(`‚ùå Debug: Aucun joueur trouv√© dans le tier ${targetTier}, joueur probablement hors leaderboard`);
                return null;
            }

            showChangeIndicator(changeValue) {
                const rrDisplay = document.getElementById('rrDisplay');

                const existingIndicator = rrDisplay.querySelector('.rr-change');
                if (existingIndicator) {
                    existingIndicator.remove();
                }

                const changeElement = document.createElement('div');
                changeElement.className = `rr-change ${changeValue > 0 ? 'positive' : 'negative'}`;
                changeElement.textContent = changeValue > 0 ? `+${changeValue}` : `${changeValue}`;

                rrDisplay.appendChild(changeElement);

                setTimeout(() => {
                    if (changeElement.parentNode) {
                        changeElement.remove();
                    }
                }, 2000);
            }

            displayError(message) {
                const rankIcon = document.getElementById('rankIcon');
                const rrDisplay = document.getElementById('rrDisplay');

                console.error('‚ùå Erreur:', message);
            }

            async fetchRealRankData() {
                try {
                    console.log('üöÄ D√©but de fetchRealRankData...');
                    console.log('üë§ Joueur:', this.playerName, '/', this.playerTag);

                    if (!this.validateConfiguration()) {
                        throw new Error('Configuration invalide');
                    }

                    const apiUrl = `https://api.henrikdev.xyz/valorant/v3/mmr/${this.apiRegion}/${this.apiPlatform}/${this.playerName}/${this.playerTag}?api_key=${this.apiKey}`;
                    console.log('üåê URL API:', apiUrl);

                    console.log('üì° Envoi de la requ√™te vers l\'API...');
                    const response = await fetch(apiUrl);

                    console.log('üìã Statut de la r√©ponse:', response.status, response.statusText);
                    console.log('üìã Headers de la r√©ponse:', Object.fromEntries(response.headers.entries()));

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status} - ${response.statusText}`);
                    }

                    console.log('üì¶ Parsing du JSON...');
                    const json = await response.json();
                    console.log('üìÑ R√©ponse compl√®te de l\'API:', json);

                    if (!json.data) {
                        console.error('‚ùå Pas de donn√©es dans la r√©ponse:', json);
                        throw new Error('Aucune donn√©e re√ßue de l\'API');
                    }

                    const data = json.data;
                    console.log('üéØ Donn√©es du joueur:', data);

                    const oldRR = this.currentRankData.rr;
                    const oldTier = this.currentRankData.tier;
                    const newRR = data.current.rr;
                    const newTier = data.current.tier.id;
                    const changeValue = data.current.last_change;

                    this.currentRankData = {
                        rank: data.current.tier.name,
                        rr: newRR,
                        tier: newTier
                    };

                    console.log('‚úÖ Donn√©es de rang mises √† jour:', this.currentRankData);

                    if (oldTier !== newTier) {
                        console.log(`üèÜ Changement de rang d√©tect√©: ${oldTier} ‚Üí ${newTier}`);
                        this.updateRankImage();
                    }

                    if (oldRR !== newRR) {
                        console.log(`üé¨ Animation RR: ${oldRR} ‚Üí ${newRR} (change: ${changeValue})`);
                        await this.animateRRChange(oldRR, newRR, changeValue);
                    } else {
                        this.displayCurrentRank();
                    }

                    await this.saveRankData();

                    console.log('üéâ fetchRealRankData termin√© avec succ√®s!');
                    return true;

                } catch (error) {
                    console.error('‚ùå Erreur dans fetchRealRankData:', error);
                    console.error('üìä Stack trace:', error.stack);
                    this.displayError('Erreur API');
                    return false;
                }
            }
}

    document.addEventListener('DOMContentLoaded', async () => {
        console.log('üöÄ D√©marrage du widget Valorant Rank avec syst√®me de commandes...');
        const widget = new ValorantRankWidget();

        window.valorantWidget = widget;
        console.log('üîß Widget accessible via window.valorantWidget pour les tests');

    });
    </script>
</body>
</html>
