<!DOCTYPE html>
<!-- GitViz ‚Äì URL Builder & Editor
* what are you doing here ?
* are you trying to copy my code ? or looking if its ai generated ?
* if you are, you are not gonna find anything here.
* this is a custom code that i wrote for my own use.
* if you want to use it, you can, but you need to ask me for permission.
* if you are not trying to copy my code, or looking if its ai generated, then you can continue.
* i hope you enjoy my code.
* if you have any questions, feel free to ask me.
* if you have any suggestions, feel free to suggest them.
* if you have any bugs, feel free to report them.
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoL Rank Widget</title>
    <!-- Google Fonts for custom font selection -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Poppins:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Raleway:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Ubuntu:wght@400;700&family=Nunito:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Crimson+Text:wght@400;700&family=Libre+Baskerville:wght@400;700&family=PT+Sans:wght@400;700&family=PT+Serif:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Bebas+Neue&family=Anton&family=Fjalla+One&family=Righteous&family=Bangers&family=Fredoka+One:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&family=Work+Sans:wght@400;700&family=Space+Grotesk:wght@400;700&family=DM+Sans:wght@400;700&family=Manrope:wght@400;700&family=Sora:wght@400;700&family=Outfit:wght@400;700&family=Plus+Jakarta+Sans:wght@400;700&family=Figtree:wght@400;700&family=Geist:wght@400;700&family=JetBrains+Mono:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
        <!--
        ========================================
        PARAM√àTRES URL DISPONIBLES
        ========================================

        üéÆ CONFIGURATION DU JOUEUR:
        ?name=SummonerName

        üåê CONFIGURATION R√âGION:
        ?region=euw1 (euw1, eun1, na1, kr, etc.)

        ‚è∞ INTERVALLE DE MISE √Ä JOUR:
        ?update_interval=60000 (en millisecondes, d√©faut: 60000)

        üì∫ CONFIGURATION TWITCH:
        ?channel=nom_canal&nick=nom_utilisateur&pass=mot_de_passe

        üëÆ CONFIGURATION DES PERMISSIONS:
        ?moderators=user1,user2,user3&vips=user1,user2&blacklist=user1,user2

        üé® STYLE:
        ?font=Arial&font_size=24&font_effect=normal&rank_image_size=60&overlay_style=default

        üìù EXEMPLE COMPLET:
        ?name=SummonerName&region=euw1&update_interval=60000

        ========================================
        COMMANDES DE CHAT DISPONIBLES
        ========================================

        üéÆ !showrank    - Affiche le widget de rang (Mod√©rateurs + VIPs uniquement)
        üôà !hiderank    - Masque le widget de rang (Mod√©rateurs + VIPs uniquement)
        üîÑ !refreshrank - Recharge la page (Mod√©rateurs + VIPs uniquement)
        üîÑ !rankreload  - Recharge la page (Mod√©rateurs + VIPs uniquement)

        ========================================
        -->
    <style>
        /* Fonts are loaded via Google Fonts in the head */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--custom-font, 'Arial', sans-serif);
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        .rank-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Overlay Style: Default (current style) */
        .overlay-style-default .rank-container {
            background: transparent;
            border: none;
            padding: 0;
        }

        /* Overlay Style: Card */
        .overlay-style-card .rank-container {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
        }

        /* Overlay Style: Bubble */
        .overlay-style-bubble .rank-container {
            background: linear-gradient(135deg, rgba(145, 70, 255, 0.2), rgba(54, 209, 220, 0.2));
            border: 2px solid rgba(145, 70, 255, 0.3);
            border-radius: 24px;
            padding: 14px 20px;
            backdrop-filter: blur(10px);
        }

        /* Overlay Style: Minimal */
        .overlay-style-minimal .rank-container {
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid rgba(0, 255, 136, 0.5);
            border-radius: 0;
            padding: 10px 16px;
        }

        /* Overlay Style: Gradient */
        .overlay-style-gradient .rank-container {
            background: linear-gradient(90deg, rgba(145, 70, 255, 0.15), rgba(54, 209, 220, 0.15));
            border: 1px solid rgba(145, 70, 255, 0.3);
            border-radius: 16px;
            padding: 12px 18px;
            box-shadow: 0 2px 8px rgba(145, 70, 255, 0.1);
        }

        /* Overlay Style: Glass */
        .overlay-style-glass .rank-container {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 14px 20px;
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .rank-icon {
            width: var(--rank-image-size, 60px);
            height: var(--rank-image-size, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-icon img {
            width: var(--rank-image-size, 60px);
            height: var(--rank-image-size, 60px);
            object-fit: contain;
        }

        .rank-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .lp-display {
            font-size: var(--font-size-main, 24px);
            font-weight: bold;
            color: #ffffff;
            position: relative;
        }

        .lp-change {
            position: absolute;
            left: -80px;
            top: 0;
            font-size: var(--font-size-change, 20px);
            font-weight: bold;
            opacity: 0;
            transform: translateY(0);
            animation: slideAndFade 2s ease-out forwards;
            pointer-events: none;
        }

        .lp-change.positive {
            color: #00ff00;
        }

        .lp-change.negative {
            color: #ff0000;
        }

        @keyframes slideAndFade {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            50% {
                opacity: 1;
                transform: translateY(-10px);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .loading {
            font-size: var(--font-size-position, 16px);
        }

        /* Font effects */
        .font-hollow {
            -webkit-text-stroke: 2px;
            -webkit-text-stroke-color: currentColor;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .font-border {
            text-shadow:
                -2px -2px 0 currentColor,
                2px -2px 0 currentColor,
                -2px 2px 0 currentColor,
                2px 2px 0 currentColor,
                0 -2px 0 currentColor,
                0 2px 0 currentColor,
                -2px 0 0 currentColor,
                2px 0 0 currentColor;
        }

        .error {
            color: #ff0000;
        }

        /* Command feedback styles */
        .command-feedback {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .command-feedback.show {
            opacity: 1;
            transform: translateX(0);
        }

        .command-feedback.success {
            background-color: #00ff00;
            color: #000;
        }

        .command-feedback.error {
            background-color: #ff0000;
        }

        /* Overlay visibility control */
        body.hidden {
            display: none !important;
        }
    </style>
</head>
<body class="overlay-style-default">
    <div class="rank-container" id="rankContainer">
        <div class="rank-icon" id="rankIcon">
            <!-- Will be populated dynamically -->
        </div>
        <div class="rank-info">
            <div class="lp-display" id="lpDisplay">-- LP</div>
        </div>
    </div>

    <!-- Command feedback element -->
    <div class="command-feedback" id="commandFeedback"></div>

    <script>
        class LoLRankWidget {
            constructor() {
                // Get all customizable values from URL parameters
                const urlParams = new URLSearchParams(window.location.search);

                // Player info
                this.playerName = urlParams.get('name') || 'username';
                this.playerTag = urlParams.get('tag') || 'tags';

                // Region configuration
                this.region = urlParams.get('region') || 'euw1';

                // Cloudflare worker proxy URL
                this.proxyUrl = 'https://overlay-api-proxy.jaysonpasquier-contact.workers.dev/';

                // Font configuration
                const fontParam = urlParams.get('font') || 'Arial';
                this.applyFont(fontParam);

                // Style configuration
                this.fontSize = parseInt(urlParams.get('font_size')) || 24;
                this.fontEffect = urlParams.get('font_effect') || 'normal';
                this.rankImageSize = parseInt(urlParams.get('rank_image_size')) || 60;
                this.overlayStyle = urlParams.get('overlay_style') || 'default';

                // Apply styles immediately
                this.applyStyles();
                this.applyOverlayStyle();

                // Update interval (in milliseconds)
                this.updateInterval = parseInt(urlParams.get('update_interval')) || 60000; // 1 minute default

                // Twitch chat configuration
                this.twitchChannel = urlParams.get('channel') || 'twitch_channel';
                this.twitchNick = urlParams.get('nick') || 'justinfan12345';
                this.twitchPass = urlParams.get('pass') || 'SCHMOOPIIE';

                // Role-based access control system
                this.moderators = this.parseUserList(urlParams.get('moderators'));
                this.vips = this.parseUserList(urlParams.get('vips'));
                this.blacklist = this.parseUserList(urlParams.get('blacklist'));

                // Default user lists if none provided
                if (this.moderators.length === 0) {
                    this.moderators = ['sc0rpio74890']; // Default moderator
                }
                if (this.vips.length === 0) {
                    this.vips = ['sc0rpio74890']; // Default VIP
                }
                if (this.blacklist.length === 0) {
                    this.blacklist = ['banned_user1', 'banned_user2']; // Default blacklist
                }

                // Overlay visibility state
                this.isOverlayVisible = true;

                // Current rank data
                this.currentRankData = {
                    tier: 'UNRANKED',
                    rank: '',
                    lp: 0,
                    wins: 0,
                    losses: 0
                };

                // Store previous values for comparison
                this.previousLP = 0;
                this.lastChange = null;
                this.isAnimating = false;

                // Mapping des rangs LoL avec les images locales
                // Format: tier-rank (e.g., "IRON-I", "DIAMOND-II")
                this.rankImages = {
                    'IRON-I': 'images/Iron.png',
                    'IRON-II': 'images/Iron.png',
                    'IRON-III': 'images/Iron.png',
                    'IRON-IV': 'images/Iron.png',
                    'BRONZE-I': 'images/Bronze.png',
                    'BRONZE-II': 'images/Bronze.png',
                    'BRONZE-III': 'images/Bronze.png',
                    'BRONZE-IV': 'images/Bronze.png',
                    'SILVER-I': 'images/Silver.png',
                    'SILVER-II': 'images/Silver.png',
                    'SILVER-III': 'images/Silver.png',
                    'SILVER-IV': 'images/Silver.png',
                    'GOLD-I': 'images/Gold.png',
                    'GOLD-II': 'images/Gold.png',
                    'GOLD-III': 'images/Gold.png',
                    'GOLD-IV': 'images/Gold.png',
                    'PLATINUM-I': 'images/Platinum.png',
                    'PLATINUM-II': 'images/Platinum.png',
                    'PLATINUM-III': 'images/Platinum.png',
                    'PLATINUM-IV': 'images/Platinum.png',
                    'EMERALD-I': 'images/Emerald.png',
                    'EMERALD-II': 'images/Emerald.png',
                    'EMERALD-III': 'images/Emerald.png',
                    'EMERALD-IV': 'images/Emerald.png',
                    'DIAMOND-I': 'images/Diamond.png',
                    'DIAMOND-II': 'images/Diamond.png',
                    'DIAMOND-III': 'images/Diamond.png',
                    'DIAMOND-IV': 'images/Diamond.png',
                    'MASTER': 'images/Master.png',
                    'GRANDMASTER': 'images/Grandmaster.png',
                    'CHALLENGER': 'images/Challenger.png',
                    'UNRANKED': 'images/Unrated.png'
                };

                // Log configuration
                this.logConfiguration();

                // Set up URL change detection
                this.setupURLChangeDetection();

                this.init();
            }

            // Helper method to parse comma-separated user lists from URL parameters
            parseUserList(paramValue) {
                if (!paramValue) return [];
                return paramValue.split(',').map(user => user.trim().toLowerCase()).filter(user => user.length > 0);
            }

            // Log current configuration for debugging
            logConfiguration() {
                console.log('üîß Configuration du widget LoL:');
                console.log(`   üë§ Joueur: ${this.playerName}#${this.playerTag}`);
                console.log(`   üåê R√©gion: ${this.region}`);
                console.log(`   ‚è∞ Mise √† jour: ${this.updateInterval}ms`);
                console.log(`   üì∫ Canal Twitch: #${this.twitchChannel}`);
                console.log(`   üëÆ Mod√©rateurs: ${this.moderators.join(', ')}`);
                console.log(`   üëë VIPs: ${this.vips.join(', ')}`);
                console.log(`   üö´ Blacklist: ${this.blacklist.join(', ')}`);

                if (this.validateConfiguration()) {
                    console.log('‚úÖ Configuration valide, affichage des donn√©es...');
                } else {
                    console.log('‚ùå Configuration invalide, v√©rifiez les param√®tres URL');
                }
            }

            // Clear old cached data for different players
            clearOldCachedData() {
                console.log('üßπ Nettoyage des anciennes donn√©es en cache...');

                const keys = Object.keys(localStorage);
                const currentPlayerKey = `lol-rank-data-${this.playerName}-${this.playerTag}-${this.region}`;

                keys.forEach(key => {
                    if (key.startsWith('lol-rank-data-') && key !== currentPlayerKey) {
                        console.log(`üóëÔ∏è Suppression des anciennes donn√©es de rang: ${key}`);
                        localStorage.removeItem(key);
                    }
                });

                console.log('‚úÖ Nettoyage des anciennes donn√©es termin√©');
            }

            // Validate configuration before making API calls
            validateConfiguration() {
                console.log('üîç Validation de la configuration...');

                if (!this.playerName || this.playerName === 'username') {
                    console.error('‚ùå Nom du joueur manquant');
                    this.showConfigurationError('Nom du joueur manquant');
                    return false;
                }

                if (!this.playerTag || this.playerTag === 'tags') {
                    console.error('‚ùå Tag du joueur manquant');
                    this.showConfigurationError('Tag du joueur manquant');
                    return false;
                }

                if (!this.region) {
                    console.error('‚ùå R√©gion manquante');
                    this.showConfigurationError('R√©gion manquante');
                    return false;
                }

                console.log('‚úÖ Configuration valid√©e');
                this.resetDisplayStyle();
                return true;
            }

            // Show configuration error message
            showConfigurationError(message) {
                console.error('‚ùå Erreur de configuration:', message);

                const rankIcon = document.getElementById('rankIcon');
                const lpDisplay = document.getElementById('lpDisplay');

                rankIcon.innerHTML = '<div style="color: #ff0000; font-size: 12px; text-align: center;">‚ùå<br>Config<br>Error</div>';

                lpDisplay.textContent = message;
                lpDisplay.style.color = '#ff0000';
            }

            // Reset display style after successful configuration
            resetDisplayStyle() {
                const lpDisplay = document.getElementById('lpDisplay');
                if (lpDisplay) {
                    lpDisplay.style.color = '#ffffff';
                }
            }

            // Apply styles (font size, font effect, rank image size)
            applyStyles() {
                const root = document.documentElement;

                root.style.setProperty('--font-size-main', `${this.fontSize}px`);
                root.style.setProperty('--font-size-change', `${Math.max(8, this.fontSize - 4)}px`);

                const lpDisplay = document.getElementById('lpDisplay');

                if (lpDisplay) {
                    lpDisplay.classList.remove('font-normal', 'font-hollow', 'font-border');
                    lpDisplay.classList.add(`font-${this.fontEffect}`);
                }

                root.style.setProperty('--rank-image-size', `${this.rankImageSize}px`);
                const rankIcon = document.getElementById('rankIcon');
                if (rankIcon) {
                    rankIcon.style.width = `${this.rankImageSize}px`;
                    rankIcon.style.height = `${this.rankImageSize}px`;
                    const rankImage = rankIcon.querySelector('img');
                    if (rankImage) {
                        rankImage.style.width = `${this.rankImageSize}px`;
                        rankImage.style.height = `${this.rankImageSize}px`;
                    }
                }
            }

            applyOverlayStyle() {
                const container = document.getElementById('rankContainer');
                if (!container) return;

                const parent = container.parentElement || document.body;

                parent.classList.remove(
                    'overlay-style-default',
                    'overlay-style-card',
                    'overlay-style-bubble',
                    'overlay-style-minimal',
                    'overlay-style-gradient',
                    'overlay-style-glass'
                );

                parent.classList.add(`overlay-style-${this.overlayStyle}`);
            }

            // Apply font from parameter
            applyFont(fontName) {
                if (!fontName) fontName = 'Arial';

                const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];

                let fontFamily;
                if (systemFonts.includes(fontName)) {
                    fontFamily = fontName;
                } else {
                    fontFamily = `'${fontName}'`;
                }

                document.documentElement.style.setProperty('--custom-font', `${fontFamily}, sans-serif`);
                document.body.style.fontFamily = `${fontFamily}, sans-serif`;

                console.log(`üî§ Police appliqu√©e: ${fontName} (${fontFamily})`);
            }

            // Set up URL change detection for dynamic configuration updates
            setupURLChangeDetection() {
                console.log('üîç Configuration de la d√©tection des changements d\'URL...');

                let currentURL = window.location.href;

                setInterval(() => {
                    if (window.location.href !== currentURL) {
                        console.log('üîÑ Changement d\'URL d√©tect√©, rechargement de la configuration...');
                        currentURL = window.location.href;
                        this.reloadConfiguration();
                    }
                }, 1000);

                console.log('‚úÖ D√©tection des changements d\'URL configur√©e');
            }

            // Method to reload configuration from URL parameters
            reloadConfiguration() {
                console.log('üîÑ Rechargement de la configuration depuis les param√®tres URL...');

                const urlParams = new URLSearchParams(window.location.search);

                const oldPlayerName = this.playerName;
                const oldPlayerTag = this.playerTag;

                this.playerName = urlParams.get('name') || this.playerName;
                this.playerTag = urlParams.get('tag') || this.playerTag;
                this.region = urlParams.get('region') || this.region;

                const newInterval = urlParams.get('update_interval');
                if (newInterval) {
                    this.updateInterval = parseInt(newInterval) || this.updateInterval;
                }

                const newFont = urlParams.get('font') || 'Arial';
                this.applyFont(newFont);

                const newFontSize = urlParams.get('font_size');
                if (newFontSize) {
                    this.fontSize = parseInt(newFontSize) || this.fontSize;
                }
                const newFontEffect = urlParams.get('font_effect');
                if (newFontEffect) {
                    this.fontEffect = newFontEffect;
                }
                const newRankImageSize = urlParams.get('rank_image_size');
                if (newRankImageSize) {
                    this.rankImageSize = parseInt(newRankImageSize) || this.rankImageSize;
                }
                const newOverlayStyle = urlParams.get('overlay_style');
                if (newOverlayStyle) {
                    this.overlayStyle = newOverlayStyle;
                }

                this.applyStyles();
                this.applyOverlayStyle();

                this.twitchChannel = urlParams.get('channel') || this.twitchChannel;
                this.twitchNick = urlParams.get('nick') || this.twitchNick;
                this.twitchPass = urlParams.get('pass') || this.twitchPass;

                const newModerators = this.parseUserList(urlParams.get('moderators'));
                const newVips = this.parseUserList(urlParams.get('vips'));
                const newBlacklist = this.parseUserList(urlParams.get('blacklist'));

                if (newModerators.length > 0) this.moderators = newModerators;
                if (newVips.length > 0) this.vips = newVips;
                if (newBlacklist.length > 0) this.blacklist = newBlacklist;

                this.logConfiguration();

                if (oldPlayerName !== this.playerName || oldPlayerTag !== this.playerTag) {
                    console.log('üîÑ Joueur chang√©, for√ßage de la mise √† jour des donn√©es...');
                    this.forceRefreshData();
                }

                console.log('‚úÖ Configuration recharg√©e avec succ√®s!');
            }

            // Check if user has permission to use commands
            hasPermission(username, userTags) {
                if (this.blacklist.includes(username.toLowerCase())) {
                    console.log(`üö´ Utilisateur ${username} est dans la blacklist`);
                    return false;
                }

                if (this.moderators.includes(username.toLowerCase())) {
                    console.log(`‚úÖ ${username} est mod√©rateur`);
                    return true;
                }

                if (this.vips.includes(username.toLowerCase())) {
                    console.log(`‚úÖ ${username} est VIP`);
                    return true;
                }

                if (userTags) {
                    if (userTags.includes('moderator=1') || userTags.includes('vip=1')) {
                        console.log(`‚úÖ ${username} a les permissions via tags Twitch`);
                        return true;
                    }
                }

                console.log(`‚ùå ${username} n'a pas les permissions`);
                return false;
            }

            // Show the overlay
            showOverlay() {
                if (!this.isOverlayVisible) {
                    this.isOverlayVisible = true;
                    document.body.classList.remove('hidden');
                    console.log('üëÅÔ∏è Overlay affich√© via commande');
                }
            }

            // Hide the overlay
            hideOverlay() {
                if (this.isOverlayVisible) {
                    this.isOverlayVisible = false;
                    document.body.classList.add('hidden');
                    console.log('üôà Overlay masqu√© via commande');
                }
            }

            // Show command feedback
            showCommandFeedback(message, type = 'success') {
                const feedback = document.getElementById('commandFeedback');
                feedback.textContent = message;
                feedback.className = `command-feedback ${type}`;

                setTimeout(() => {
                    feedback.classList.add('show');
                }, 100);

                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 3000);
            }

            // Parse and handle chat commands
            parseChatCommand(username, message, userTags) {
                const command = message.trim().toLowerCase();

                if (command === '!showrank') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üéÆ Commande !showrank re√ßue de ${username}`);
                        this.showOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !showrank sans permission`);
                    }
                    return;
                }

                if (command === '!hiderank') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üéÆ Commande !hiderank re√ßue de ${username}`);
                        this.hideOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !hiderank sans permission`);
                    }
                    return;
                }

                if (command === '!refreshrank' || command === '!rankreload') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üîÑ Commande ${command} re√ßue de ${username} - Rechargement forc√© de la page...`);
                        window.location.reload();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser ${command} sans permission`);
                    }
                    return;
                }

                if (command.startsWith('!')) {
                    console.log(`‚ùì Commande inconnue re√ßue de ${username}: ${command}`);
                }
            }

            async init() {
                console.log('üéÆ Initialisation du widget LoL Rank...');
                console.log(`üë§ Joueur: ${this.playerName}#${this.playerTag}`);

                this.clearOldCachedData();

                await this.loadRankData();

                this.displayCurrentRank();

                console.log('üß™ Test de l\'API en cours...');
                await this.fetchRealRankData();

                this.connectToTwitchChat();

                setInterval(async () => {
                    console.log('üîÑ Mise √† jour automatique via l\'API...');
                    await this.fetchRealRankData();
                }, this.updateInterval);

                setInterval(() => {
                    if (!this.isAnimating) {
                        this.displayCurrentRank();
                    }
                }, 30000);
            }

            async loadRankData() {
                try {
                    const savedData = localStorage.getItem(`lol-rank-data-${this.playerName}-${this.playerTag}-${this.region}`);
                    if (savedData) {
                        const loadedData = JSON.parse(savedData);
                        this.currentRankData = {
                            tier: loadedData.tier,
                            rank: loadedData.rank,
                            lp: loadedData.lp,
                            wins: loadedData.wins,
                            losses: loadedData.losses
                        };
                        this.previousLP = loadedData.lp;
                        this.lastChange = loadedData.lastChange || null;
                        console.log('‚úÖ Donn√©es de rang charg√©es depuis localStorage:', this.currentRankData);
                        return true;
                    } else {
                        console.log('üìÑ Aucune donn√©e sauvegard√©e trouv√©e');
                        this.previousLP = this.currentRankData.lp;
                        return false;
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger les donn√©es sauvegard√©es');
                    this.previousLP = this.currentRankData.lp;
                    return false;
                }
            }

            async saveRankData() {
                try {
                    const dataToSave = {
                        tier: this.currentRankData.tier,
                        rank: this.currentRankData.rank,
                        lp: this.currentRankData.lp,
                        wins: this.currentRankData.wins,
                        losses: this.currentRankData.losses,
                        lastChange: this.lastChange,
                        lastUpdated: new Date().toISOString()
                    };

                    localStorage.setItem(`lol-rank-data-${this.playerName}-${this.playerTag}-${this.region}`, JSON.stringify(dataToSave));

                    console.log('üíæ Donn√©es de rang sauvegard√©es dans localStorage:', dataToSave);
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde:', error);
                }
            }

            connectToTwitchChat() {
                console.log('üîó Connexion au chat Twitch pour √©couter les commandes...');

                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('‚úÖ Connect√© au chat Twitch');
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send(`PASS ${this.twitchPass}`);
                    socket.send(`NICK ${this.twitchNick}`);
                    socket.send(`JOIN #${this.twitchChannel}`);
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    this.parseChatMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('‚ùå Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('üîå Connexion au chat Twitch ferm√©e');
                    setTimeout(() => {
                        console.log('üîÑ Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 10000);
                };
            }

            parseChatMessage(rawMessage) {
                try {
                    if (!rawMessage.includes(`PRIVMSG #${this.twitchChannel} :`)) {
                        return;
                    }

                    const tagsMatch = rawMessage.match(/@([^ ]+) /);
                    let userTags = '';
                    if (tagsMatch) {
                        userTags = tagsMatch[1];
                    }

                    const userMatch = rawMessage.match(/:([^!]+)!/);
                    if (!userMatch) return;
                    const username = userMatch[1].toLowerCase();

                    const messageMatch = rawMessage.match(new RegExp(`PRIVMSG #${this.twitchChannel} :(.+)`));
                    if (!messageMatch) return;
                    const messageContent = messageMatch[1].trim();

                    console.log(`üí¨ Message de ${username}: ${messageContent}`);

                    if (messageContent.startsWith('!')) {
                        this.parseChatCommand(username, messageContent, userTags);
                    }

                } catch (error) {
                    console.error('‚ùå Erreur lors du parsing du message:', error);
                }
            }

            displayCurrentRank() {
                const lpDisplay = document.getElementById('lpDisplay');
                const rankIcon = document.getElementById('rankIcon');

                const data = this.currentRankData;

                if (data.tier === 'UNRANKED' || !data.tier) {
                    rankIcon.innerHTML = `<img src="images/Unrated.png" alt="Unranked" style="width: ${this.rankImageSize}px; height: ${this.rankImageSize}px;">`;
                    lpDisplay.textContent = 'Unranked';
                    lpDisplay.style.display = 'block';
                    console.log(`‚úÖ Affichage mis √† jour: Unranked`);
                    return;
                }

                lpDisplay.style.display = 'block';

                const rankKey = data.rank ? `${data.tier}-${data.rank}` : data.tier;
                const rankImagePath = this.rankImages[rankKey] || this.rankImages[data.tier] || 'images/Unrated.png';

                const currentImage = rankIcon.querySelector('img');
                const currentImageSrc = currentImage ? currentImage.src : '';
                const newImageName = rankImagePath.split('/').pop();
                if (!currentImage || !currentImageSrc.includes(newImageName)) {
                    rankIcon.innerHTML = `<img src="${rankImagePath}" alt="${data.tier} ${data.rank}" style="width: ${this.rankImageSize}px; height: ${this.rankImageSize}px;">`;
                    console.log(`üñºÔ∏è Image de rang charg√©e: ${rankImagePath}`);
                } else {
                    currentImage.style.width = `${this.rankImageSize}px`;
                    currentImage.style.height = `${this.rankImageSize}px`;
                }

                if (!this.isAnimating) {
                    const currentLPText = lpDisplay.textContent.trim();
                    const newLPText = `${data.lp} LP`;
                    if (currentLPText !== newLPText) {
                        lpDisplay.textContent = newLPText;
                    }
                }

                console.log(`‚úÖ Affichage mis √† jour: ${data.tier} ${data.rank} - ${data.lp} LP`);
            }

            async animateLPChange(oldLP, newLP, changeValue = null) {
                if (this.isAnimating) return;
                this.isAnimating = true;

                const lpDisplay = document.getElementById('lpDisplay');

                if (changeValue !== null && changeValue !== this.lastChange) {
                    this.showChangeIndicator(changeValue);
                    this.lastChange = changeValue;
                }

                const difference = newLP - oldLP;
                const steps = Math.min(Math.abs(difference), 50);
                const stepSize = difference / steps;
                const stepDelay = 30;

                for (let i = 0; i <= steps; i++) {
                    const currentLP = Math.round(oldLP + (stepSize * i));
                    lpDisplay.textContent = `${currentLP} LP`;

                    if (i < steps) {
                        await new Promise(resolve => setTimeout(resolve, stepDelay));
                    }
                }

                this.isAnimating = false;
            }

            showChangeIndicator(changeValue) {
                const lpDisplay = document.getElementById('lpDisplay');

                const existingIndicator = lpDisplay.querySelector('.lp-change');
                if (existingIndicator) {
                    existingIndicator.remove();
                }

                const changeElement = document.createElement('div');
                changeElement.className = `lp-change ${changeValue > 0 ? 'positive' : 'negative'}`;
                changeElement.textContent = changeValue > 0 ? `+${changeValue}` : `${changeValue}`;

                lpDisplay.appendChild(changeElement);

                setTimeout(() => {
                    if (changeElement.parentNode) {
                        changeElement.remove();
                    }
                }, 2000);
            }

            displayError(message) {
                const rankIcon = document.getElementById('rankIcon');
                const lpDisplay = document.getElementById('lpDisplay');

                console.error('‚ùå Erreur:', message);
            }

            async forceRefreshData() {
                console.log('üîÑ For√ßage de la mise √† jour des donn√©es pour', this.playerName, this.playerTag);
                try {
                    await this.fetchRealRankData();
                    console.log('‚úÖ Donn√©es forc√©ment mises √† jour pour', this.playerName, this.playerTag);
                } catch (error) {
                    console.error('‚ùå Erreur lors du for√ßage de la mise √† jour:', error);
                }
            }

            // Fetch rank data from LoL API via Cloudflare worker
            async fetchRealRankData() {
                try {
                    console.log('üöÄ D√©but de fetchRealRankData...');
                    console.log('üë§ Joueur:', this.playerName, '/', this.playerTag);
                    console.log('üåê R√©gion:', this.region);

                    if (!this.validateConfiguration()) {
                        throw new Error('Configuration invalide');
                    }

                    // Step 1: Get account by Riot ID (gameName + tagLine)
                    // The account API uses routing regions (americas, europe, asia)
                    const accountRegionMap = {
                        'euw1': 'europe', 'eun1': 'europe',
                        'na1': 'americas', 'la1': 'americas', 'la2': 'americas', 'br1': 'americas',
                        'kr': 'asia', 'jp1': 'asia', 'ru': 'europe', 'tr1': 'europe',
                        'oc1': 'asia', 'ph2': 'asia', 'sg2': 'asia', 'th2': 'asia', 'tw2': 'asia', 'vn2': 'asia'
                    };
                    const routingRegion = accountRegionMap[this.region] || 'europe';

                    // Get PUUID from Riot Account API
                    const accountEndpoint = `account/v1/accounts/by-riot-id/${encodeURIComponent(this.playerName)}/${encodeURIComponent(this.playerTag)}`;
                    const accountUrl = `${this.proxyUrl}?endpoint=${accountEndpoint}&region=${routingRegion}`;
                    console.log('üåê URL API Account:', accountUrl);

                    const accountResponse = await fetch(accountUrl);
                    console.log('üìã Statut de la r√©ponse Account:', accountResponse.status, accountResponse.statusText);

                    if (!accountResponse.ok) {
                        if (accountResponse.status === 404) {
                            throw new Error('Joueur introuvable');
                        }
                        throw new Error(`Erreur HTTP: ${accountResponse.status} - ${accountResponse.statusText}`);
                    }

                    const accountData = await accountResponse.json();
                    console.log('üìÑ Donn√©es du compte:', accountData);

                    if (!accountData || !accountData.puuid) {
                        throw new Error('Donn√©es du compte invalides');
                    }

                    const puuid = accountData.puuid;

                    // Step 2: Get summoner by PUUID
                    const summonerEndpoint = `summoner/v4/summoners/by-puuid/${puuid}`;
                    const summonerUrl = `${this.proxyUrl}?endpoint=${summonerEndpoint}&region=${this.region}`;
                    console.log('üåê URL API Summoner:', summonerUrl);

                    const summonerResponse = await fetch(summonerUrl);
                    console.log('üìã Statut de la r√©ponse Summoner:', summonerResponse.status, summonerResponse.statusText);

                    if (!summonerResponse.ok) {
                        if (summonerResponse.status === 404) {
                            throw new Error('Summoner introuvable');
                        }
                        throw new Error(`Erreur HTTP: ${summonerResponse.status} - ${summonerResponse.statusText}`);
                    }

                    const summonerData = await summonerResponse.json();
                    console.log('üìÑ Donn√©es du summoner:', summonerData);

                    if (!summonerData || !summonerData.id) {
                        throw new Error('Donn√©es du summoner invalides');
                    }

                    const summonerId = summonerData.id;

                    // Step 2: Get league entries by summoner ID
                    const leagueEndpoint = `league/v4/entries/by-summoner/${summonerId}`;
                    const leagueUrl = `${this.proxyUrl}?endpoint=${leagueEndpoint}&region=${this.region}`;
                    console.log('üåê URL API League:', leagueUrl);

                    const leagueResponse = await fetch(leagueUrl);
                    console.log('üìã Statut de la r√©ponse League:', leagueResponse.status, leagueResponse.statusText);

                    if (!leagueResponse.ok) {
                        throw new Error(`Erreur HTTP: ${leagueResponse.status} - ${leagueResponse.statusText}`);
                    }

                    const leagueData = await leagueResponse.json();
                    console.log('üìÑ Donn√©es de league:', leagueData);

                    // Find RANKED_SOLO_5x5 queue
                    let rankedEntry = null;
                    if (Array.isArray(leagueData)) {
                        rankedEntry = leagueData.find(entry => entry.queueType === 'RANKED_SOLO_5x5');
                    }

                    if (!rankedEntry) {
                        // Player is unranked
                        console.log('‚ö†Ô∏è Joueur non class√©');
                        this.currentRankData = {
                            tier: 'UNRANKED',
                            rank: '',
                            lp: 0,
                            wins: 0,
                            losses: 0
                        };
                        this.displayCurrentRank();
                        await this.saveRankData();
                        return true;
                    }

                    const oldLP = this.currentRankData.lp;
                    const oldTier = this.currentRankData.tier;
                    const oldRank = this.currentRankData.rank;

                    const newLP = rankedEntry.leaguePoints || 0;
                    const newTier = rankedEntry.tier || 'UNRANKED';
                    const newRank = rankedEntry.rank || '';

                    this.currentRankData = {
                        tier: newTier,
                        rank: newRank,
                        lp: newLP,
                        wins: rankedEntry.wins || 0,
                        losses: rankedEntry.losses || 0
                    };

                    console.log('‚úÖ Donn√©es de rang mises √† jour:', this.currentRankData);

                    // Update rank image if tier or rank changed
                    if (oldTier !== newTier || oldRank !== newRank) {
                        console.log(`üèÜ Changement de rang d√©tect√©: ${oldTier} ${oldRank} ‚Üí ${newTier} ${newRank}`);
                        this.displayCurrentRank();
                    }

                    // Update display with animation if LP changed
                    const lpChange = newLP - oldLP;
                    if (oldLP !== newLP && oldLP > 0) {
                        console.log(`üé¨ Animation LP: ${oldLP} ‚Üí ${newLP} (change: ${lpChange})`);
                        await this.animateLPChange(oldLP, newLP, lpChange);
                    } else {
                        this.displayCurrentRank();
                    }

                    await this.saveRankData();

                    console.log('üéâ fetchRealRankData termin√© avec succ√®s!');
                    return true;

                } catch (error) {
                    console.error('‚ùå Erreur dans fetchRealRankData:', error);
                    console.error('üìä Stack trace:', error.stack);
                    this.displayError('Erreur API');
                    return false;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ D√©marrage du widget LoL Rank...');
            const widget = new LoLRankWidget();

            window.lolWidget = widget;
            console.log('üîß Widget accessible via window.lolWidget pour les tests');
        });
    </script>
</body>
</html>

