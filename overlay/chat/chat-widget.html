<!DOCTYPE html>
<!-- GitVize ‚Äì URL Builder & Editor
* what are you doing here ?
* are you trying to copy my code ? or looking if its ai generated ?
* if you are, you are not gonna find anything here.
* this is a custom code that i wrote for my own use.
* if you want to use it, you can, but you need to ask me for permission.
* if you are not trying to copy my code, or looking if its ai generated, then you can continue.
* i hope you enjoy my code.
* if you have any questions, feel free to ask me.
* if you have any suggestions, feel free to suggest them.
* if you have any bugs, feel free to report them.
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Widget </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Poppins:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Raleway:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Ubuntu:wght@400;700&family=Nunito:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Crimson+Text:wght@400;700&family=Libre+Baskerville:wght@400;700&family=PT+Sans:wght@400;700&family=PT+Serif:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Bebas+Neue&family=Anton&family=Fjalla+One&family=Righteous&family=Bangers&family=Fredoka+One:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&family=Work+Sans:wght@400;700&family=Space+Grotesk:wght@400;700&family=DM+Sans:wght@400;700&family=Manrope:wght@400;700&family=Sora:wght@400;700&family=Outfit:wght@400;700&family=Plus+Jakarta+Sans:wght@400;700&family=Figtree:wght@400;700&family=Geist:wght@400;700&family=JetBrains+Mono:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <!--
    ========================================
    COMMANDES DE CHAT DISPONIBLES
    ========================================

    üîÑ !chatreload  - Recharge la page (Mod√©rateurs + VIPs uniquement)
    üîÑ !chatrefresh - Recharge la page (Mod√©rateurs + VIPs uniquement)

    üëÆ MOD√âRATEURS AUTORIS√âS:


    üëë VIPS AUTORIS√âS:
    sc0rpio74890

    üß™ TESTS (Console):
    window.chatWidget.testCommandPermissions('username')
    window.chatWidget.testReload()
    ========================================
    -->
    <style>
        @font-face {
            font-family: 'Sea Regular Fugu';
            src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype'),
                 url('police/sea-regular-fugu.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        /* Test de chargement de police */
        .font-test {
            font-family: 'Sea Regular Fugu', monospace;
            position: absolute;
            left: -9999px;
            font-size: 72px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--custom-font, 'Sea Regular Fugu'), 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', Arial, sans-serif;
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        #chat-container {
            height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 10px;
            overflow: hidden;
        }

        .chat-message {
            margin-bottom: 10px;
            display: block;
            animation: slideIn 0.3s ease-out;
            opacity: 0;
            transform: translateX(-20px);
            animation-fill-mode: forwards;
        }

        .username {
            font-weight: bold;
            color: #00ff88;
            display: inline;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 28px;
            line-height: 32px; /* Alignement avec la hauteur des badges */
        }

        .message-content {
            display: inline;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.5;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .separator {
            margin-right: 5px;
            font-weight: bold;
            color: #ffffff;
            font-size: 28px;
        }

        .badge-display {
            margin-right: 5px;
            font-size: 28px;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            height: 32px; /* Hauteur fixe pour aligner avec le username */
            vertical-align: bottom;
        }

        .badge-image {
            width: 28px; /* Badges plus grands */
            height: 28px; /* Badges plus grands */
            display: inline-block;
            vertical-align: middle;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-7tv {
            max-height: 28px;
            height: auto;
            max-width: 56px; /* Permet aux emotes larges d'√™tre plus grandes */
            width: auto;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-twitch {
            width: 28px;
            height: 28px;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
        }

        /* Animation pour l'arriv√©e des messages */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }



        /* Couleurs diff√©rentes pour les pseudos */
        .username.color-1 { color: #ff6b6b; }
        .username.color-2 { color: #4ecdc4; }
        .username.color-3 { color: #45b7d1; }
        .username.color-4 { color: #96ceb4; }
        .username.color-5 { color: #ffeaa7; }
        .username.color-6 { color: #dda0dd; }
        .username.color-7 { color: #98d8c8; }
        .username.color-8 { color: #f7dc6f; }
        .username.color-9 { color: #bb8fce; }
        .username.color-10 { color: #85c1e9; }

        /* Style pour les messages de mod√©rateurs */
        .moderator {
            color: #00ff00 !important;
        }

        /* Style pour les messages VIP */
        .vip {
            color: #ff69b4 !important;
        }

        /* Style pour les messages de subscribers */
        .subscriber {
            color: #9146ff !important;
        }

        /* Style pour les messages de predictions */
        .predictions {
            color: #ff6600 !important;
        }

        /* Style pour les messages premium/prime */
        .premium {
            color: #9146ff !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .username, .separator {
                font-size: 28px;
            }

            .message-content {
                font-size: 26px;
            }

            #chat-container {
                padding: 5px;
            }

            .chat-message {
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="chat-container"></div>

    <script>
        class ChatWidget {
            constructor() {
                this.container = document.getElementById('chat-container');
                this.maxMessages = 50;
                this.messages = new Map();
                this.messageCounter = 0;
                this.userColors = new Map();
                this.colorIndex = 0;
                this.colors = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5',
                              'color-6', 'color-7', 'color-8', 'color-9', 'color-10'];

                const urlParams = new URLSearchParams(window.location.search);
                this.channel = urlParams.get('channel') || 'fugu_fps';
                const fontParam = urlParams.get('font') || 'Arial';
                const modsParam = urlParams.get('moderators') || '';
                const vipsParam = urlParams.get('vips') || '';

                const twitchClientIdParam = urlParams.get('twitch_client_id');
                const twitchAuthTokenParam = urlParams.get('twitch_auth_token');
                const broadcasterIdParam = urlParams.get('broadcaster_id');

                this.applyFont(fontParam);

                this.sevenTVEmotes = new Map();
                this.globalSevenTVEmotes = new Map();

                this.channelCache = new Map();

                this.sharedChatParticipants = new Set();
                this.isSharedChatActive = false;

                this.twitchClientId = twitchClientIdParam || '';
                this.twitchAuthToken = twitchAuthTokenParam || '';
                this.broadcasterId = broadcasterIdParam || '';

                this.badgeCache = new Map();
                this.globalBadgeCache = new Map();

                this.moderationCache = new Map();
                this.lastModerationCheck = 0;

                this.debugMode = true;
                this.ircMessageLog = [];

                const defaultMods = [
                ];

                const defaultVips = [
                    'sc0rpio74890',
                ];

                this.moderators = modsParam
                    ? modsParam.split(',').map(m => m.trim().toLowerCase()).filter(m => m)
                    : defaultMods.map(m => m.toLowerCase());

                this.vips = vipsParam
                    ? vipsParam.split(',').map(v => v.trim().toLowerCase()).filter(v => v)
                    : defaultVips.map(v => v.toLowerCase());

                this.blacklist = [
                    'banned_user1',
                    'banned_user2'
                ];

                const hasAllCredentials = this.channel &&
                                         this.broadcasterId &&
                                         this.twitchClientId &&
                                         this.twitchAuthToken;

                if (hasAllCredentials) {
                    console.log('‚úÖ Toutes les credentials sont pr√©sentes - utilisation des donn√©es r√©elles');
                    this.loadTwitchBadges();
                    this.startSharedChatCheck();
                    this.startModerationCheck();
                } else {
                    console.log('‚ö†Ô∏è Credentials manquantes - certaines fonctionnalit√©s seront d√©sactiv√©es');
                    console.log(`   Channel: ${this.channel ? '‚úÖ' : '‚ùå'}`);
                    console.log(`   Broadcaster ID: ${this.broadcasterId ? '‚úÖ' : '‚ùå'}`);
                    console.log(`   Client ID: ${this.twitchClientId ? '‚úÖ' : '‚ùå'}`);
                    console.log(`   Auth Token: ${this.twitchAuthToken ? '‚úÖ' : '‚ùå'}`);
                }

                this.loadSevenTVEmotes();

                this.connectToTwitchChat();

                this.initStreamlabsEvents();

                console.log(`üîê Syst√®me de commandes initialis√©:`);
                console.log(`   üëÆ Mod√©rateurs: ${this.moderators.length} (${this.moderators.join(', ')})`);
                console.log(`   üëë VIPs: ${this.vips.length} (${this.vips.join(', ')})`);
                console.log(`   üö´ Blacklist: ${this.blacklist.length} (${this.blacklist.join(', ')})`);

                console.log('üóëÔ∏è Syst√®me de suppression de messages initialis√©');
            }

            generateMessageId() {
                return `msg_${++this.messageCounter}_${Date.now()}`;
            }

            removeMessagesByUsername(username) {
                let removedCount = 0;
                const usernameLower = username.toLowerCase();

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.username.toLowerCase() === usernameLower) {
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }
                        this.messages.delete(messageId);
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Supprim√© ${removedCount} messages de ${username} (ban/timeout)`);
                }
            }

            removeMessageById(messageId) {
                const messageData = this.messages.get(messageId);
                if (messageData) {
                    if (messageData.element && messageData.element.parentNode) {
                        messageData.element.parentNode.removeChild(messageData.element);
                    }
                    this.messages.delete(messageId);
                    console.log(`üóëÔ∏è Message supprim√©: ${messageId}`);
                    return true;
                }
                return false;
            }

            cleanupOldMessages() {
                const maxStoredMessages = 50;
                if (this.messages.size > maxStoredMessages) {
                    const sortedMessages = Array.from(this.messages.entries())
                        .sort((a, b) => a[1].timestamp - b[1].timestamp);

                    const toRemove = sortedMessages.slice(0, this.messages.size - maxStoredMessages);
                    toRemove.forEach(([messageId, messageData]) => {
                        this.messages.delete(messageId);
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }
                    });

                    console.log(`üßπ Nettoyage: ${toRemove.length} anciens messages supprim√©s (limite 50 atteinte)`);
                }
            }

            async startSharedChatCheck() {
                console.log('üîÑ D√©marrage de la v√©rification du chat partag√©...');

                await this.checkSharedChat();

                setInterval(async () => {
                    await this.checkSharedChat();
                }, 5000);
            }

            startModerationCheck() {
                console.log('üõ°Ô∏è D√©marrage de la v√©rification p√©riodique de mod√©ration...');

                setInterval(() => {
                    console.log('‚è∞ Intervalle de mod√©ration d√©clench√©');
                    this.checkModerationEvents();
                }, 1000);

                console.log('‚úÖ Intervalle de mod√©ration configur√© pour toutes les secondes');
            }

            checkModerationEvents() {
                console.log('üîÑ checkModerationEvents() appel√©');

                this.checkRecentModerations();

                if (Date.now() % 10000 < 1000) {
                    console.log(`üìä Status stockage: ${this.messages.size}/50 messages stock√©s`);
                }
            }

            async checkRecentModerations() {
                if (!this.broadcasterId || !this.twitchClientId || !this.twitchAuthToken) {
                    console.log('‚ö†Ô∏è Credentials manquants pour la v√©rification des mod√©rations');
                    return;
                }

                try {
                    const response = await fetch(`https://api.twitch.tv/helix/moderation/banned?broadcaster_id=${this.broadcasterId}&first=100`, {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 429) {
                            console.log('‚ö†Ô∏è Rate limit atteint, pause de 5 secondes');
                            return;
                        }
                        console.error(`‚ùå Erreur API mod√©ration: ${response.status}`);
                        return;
                    }

                    const data = await response.json();

                    if (data.data && data.data.length > 0) {
                        data.data.forEach(banData => {
                            const username = banData.user_login;
                            const banReason = banData.reason || 'Aucune raison sp√©cifi√©e';
                            const expiresAt = banData.expires_at;

                            const banTime = new Date(banData.created_at);
                            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

                            if (banTime > fiveMinutesAgo) {
                                const banKey = `${username}_${banData.created_at}`;
                                if (!this.moderationCache.has(banKey)) {
                                    console.log(`üõ°Ô∏è Bannissement r√©cent d√©tect√©: ${username} - Raison: ${banReason}`);

                                    const removedCount = this.removeMessagesByUsername(username);

                                    if (removedCount > 0) {
                                        console.log(`üóëÔ∏è ${removedCount} messages supprim√©s de ${username} (bannissement r√©cent)`);
                                    }

                                    this.moderationCache.set(banKey, {
                                        username: username,
                                        reason: banReason,
                                        timestamp: Date.now()
                                    });

                                    this.cleanupModerationCache();
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('üí• Erreur lors de la v√©rification des mod√©rations:', error);
                }
            }

            cleanupModerationCache() {
                const tenMinutesAgo = Date.now() - 10 * 60 * 1000;
                for (const [key, data] of this.moderationCache.entries()) {
                    if (data.timestamp < tenMinutesAgo) {
                        this.moderationCache.delete(key);
                    }
                }
            }

            detectIRCMessageType(rawMessage) {
                if (rawMessage.includes('CLEARMSG')) return 'CLEARMSG';
                if (rawMessage.includes('CLEARCHAT')) return 'CLEARCHAT';
                if (rawMessage.includes('USERNOTICE')) return 'USERNOTICE';
                if (rawMessage.includes('PRIVMSG')) return 'PRIVMSG';
                if (rawMessage.includes('PING')) return 'PING';
                if (rawMessage.includes('PONG')) return 'PONG';
                if (rawMessage.includes('JOIN')) return 'JOIN';
                if (rawMessage.includes('PART')) return 'PART';
                if (rawMessage.includes('MODE')) return 'MODE';
                if (rawMessage.includes('NOTICE')) return 'NOTICE';
                if (rawMessage.includes('HOSTTARGET')) return 'HOSTTARGET';
                if (rawMessage.includes('RECONNECT')) return 'RECONNECT';
                if (rawMessage.includes('ROOMSTATE')) return 'ROOMSTATE';
                if (rawMessage.includes('USERSTATE')) return 'USERSTATE';
                if (rawMessage.includes('GLOBALUSERSTATE')) return 'GLOBALUSERSTATE';
                if (rawMessage.includes('CAP')) return 'CAP';
                if (rawMessage.includes('NICK')) return 'NICK';
                if (rawMessage.includes('PASS')) return 'PASS';
                return 'UNKNOWN';
            }

            async loadTwitchBadges() {
                if (!this.broadcasterId || !this.twitchClientId || !this.twitchAuthToken) {
                    console.log('‚ö†Ô∏è Credentials manquants pour le chargement des badges Twitch');
                    return;
                }

                try {
                    console.log('üè∑Ô∏è Chargement des badges Twitch...');

                    const channelResponse = await fetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${this.broadcasterId}`, {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (channelResponse.ok) {
                        const channelData = await channelResponse.json();
                        console.log('üìä Badges de cha√Æne re√ßus:', channelData);

                        if (channelData.data) {
                            channelData.data.forEach(badge => {
                                this.badgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${channelData.data.length} badges de cha√Æne charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges de cha√Æne:', channelResponse.status);
                    }

                    const globalResponse = await fetch('https://api.twitch.tv/helix/chat/badges/global', {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();
                        console.log('üìä Badges globaux re√ßus:', globalData);

                        if (globalData.data) {
                            globalData.data.forEach(badge => {
                                this.globalBadgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${globalData.data.length} badges globaux charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges globaux:', globalResponse.status);
                    }

                    console.log(`üè∑Ô∏è Total badges charg√©s: ${this.badgeCache.size} cha√Æne + ${this.globalBadgeCache.size} globaux`);
                } catch (error) {
                    console.error('üí• Erreur lors du chargement des badges Twitch:', error);
                }
            }

            getBadgeUrl(badgeType, version = '1') {
                try {
                    if (this.badgeCache.has(badgeType)) {
                        const badge = this.badgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    if (this.globalBadgeCache.has(badgeType)) {
                        const badge = this.globalBadgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    return null;
                } catch (error) {
                    console.error('‚ùå Erreur lors de la r√©cup√©ration du badge:', error);
                    return null;
                }
            }

            isModerator(username) {
                return this.moderators.includes(username.toLowerCase());
            }

            isVIP(username) {
                return this.vips.includes(username.toLowerCase());
            }

            isBlacklisted(username) {
                return this.blacklist.includes(username.toLowerCase());
            }

            hasCommandPermission(username) {
                const lowerUsername = username.toLowerCase();
                return this.isModerator(lowerUsername) || this.isVIP(lowerUsername);
            }

            handleChatCommand(username, message) {
                const lowerMessage = message.toLowerCase();
                const lowerUsername = username.toLowerCase();

                const hasPermission = this.isModerator(lowerUsername) || this.isVIP(lowerUsername);

                if (!hasPermission) {
                    console.log(`üö´ Commande refus√©e: ${username} n'a pas les permissions (${lowerMessage})`);
                    return false;
                }

                if (lowerMessage === '!chatreload' || lowerMessage === '!chatrefresh') {
                    console.log(`üîÑ Commande de rechargement ex√©cut√©e par ${username}: ${lowerMessage}`);
                    this.executePageReload();
                    return true;
                }

                return false;
            }

            executePageReload() {
                console.log('üîÑ Rechargement forc√© de la page...');

                window.location.reload();
            }

            testCommandPermissions(username) {
                console.log(`üß™ Test des permissions pour: ${username}`);
                console.log(`   üëÆ Mod√©rateur: ${this.isModerator(username)}`);
                console.log(`   üëë VIP: ${this.isVIP(username)}`);
                console.log(`   üö´ Blacklist√©: ${this.isBlacklisted(username)}`);
                console.log(`   ‚úÖ Peut utiliser les commandes: ${this.hasCommandPermission(username)}`);
            }

            testReload() {
                console.log('üß™ Test de rechargement manuel...');
                this.executePageReload();
            }

            async checkSharedChat() {
                if (!this.broadcasterId || !this.twitchClientId || !this.twitchAuthToken) {
                    console.log('‚ö†Ô∏è Credentials manquants pour la v√©rification du chat partag√©');
                    this.isSharedChatActive = false;
                    this.sharedChatParticipants.clear();
                    return;
                }

                try {
                    console.log('üîç V√©rification du chat partag√©...');

                    const response = await fetch(`https://api.twitch.tv/helix/shared_chat/session?broadcaster_id=${this.broadcasterId}`, {
                        headers: {
                            'Authorization': `Bearer ${this.twitchAuthToken}`,
                            'Client-Id': this.twitchClientId
                        }
                    });

                    if (!response.ok) {
                        console.log('‚ùå Erreur API chat partag√©:', response.status, response.statusText);
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                        return;
                    }

                    const data = await response.json();
                    console.log('üìä R√©ponse API chat partag√©:', data);

                    if (data.data && data.data.length > 0) {
                        const session = data.data[0];
                        const participants = session.participants || [];

                        this.sharedChatParticipants.clear();
                        participants.forEach(p => this.sharedChatParticipants.add(p.broadcaster_id));

                        this.isSharedChatActive = participants.length > 1;

                        console.log(`ü§ù Chat partag√©: ${this.isSharedChatActive ? 'ACTIF' : 'INACTIF'}`);
                        console.log(`üë• Participants: ${participants.length} (${Array.from(this.sharedChatParticipants).join(', ')})`);
                    } else {
                        console.log('‚ö™ Aucune session de chat partag√© trouv√©e');
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                    }
                } catch (error) {
                    console.error('üí• Erreur lors de la v√©rification du chat partag√©:', error);
                    this.isSharedChatActive = false;
                    this.sharedChatParticipants.clear();
                }
            }

            applyFont(fontName) {
                if (!fontName) fontName = 'Arial';
                const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];
                let fontFamily;
                if (systemFonts.includes(fontName)) {
                    fontFamily = fontName;
                } else {
                    fontFamily = `'${fontName}'`;
                }
                document.documentElement.style.setProperty('--custom-font', `${fontFamily}, sans-serif`);
                document.body.style.fontFamily = `${fontFamily}, sans-serif`;
            }

            connectToTwitchChat() {
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log(`Connect√© au chat Twitch de ${this.channel}`);
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send(`JOIN #${this.channel}`);
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    this.parseIRCMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('Connexion au chat Twitch ferm√©e');
                    setTimeout(() => {
                        console.log('Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 5000);
                };
            }

            async getChannelInfo(roomId) {
                if (this.channelCache.has(roomId)) {
                    return this.channelCache.get(roomId);
                }

                try {
                    console.log(`üè¢ R√©cup√©ration des infos pour room-id: ${roomId}`);
                    const res = await fetch(`https://api.twitch.tv/helix/users?id=${roomId}`, {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (!res.ok) {
                        console.error(`‚ùå Erreur API Twitch: ${res.status} ${res.statusText}`);
                        return null;
                    }

                    const json = await res.json();
                    console.log(`üìä R√©ponse API pour room-id ${roomId}:`, json);

                    if (json.data && json.data[0]) {
                        const channel = {
                            displayName: json.data[0].display_name,
                            login: json.data[0].login,
                            profileImage: json.data[0].profile_image_url
                        };
                        console.log(`‚úÖ Infos channel r√©cup√©r√©es:`, channel);
                        this.channelCache.set(roomId, channel);
                        return channel;
                    } else {
                        console.log(`‚ùå Aucune donn√©e trouv√©e pour room-id ${roomId}`);
                    }
                } catch (err) {
                    console.error('üí• Erreur lors de la r√©cup√©ration du channel info pour', roomId, err);
                }

                return null;
            }

            handleClearMsg(rawMessage) {
                try {
                    console.log('üóëÔ∏è CLEARMSG d√©tect√© (suppression de message):', rawMessage);

                    const msgIdMatch = rawMessage.match(/target-msg-id=([^;]*)/);
                    if (!msgIdMatch) {
                        console.log('‚ùå Impossible d\'extraire l\'ID du message supprim√©');
                        return;
                    }

                    const twitchMsgId = msgIdMatch[1];
                    console.log(`üéØ ID du message supprim√©: ${twitchMsgId}`);

                    const messageMatch = rawMessage.match(/CLEARMSG #\w+ :(.+)/);
                    const deletedContent = messageMatch ? messageMatch[1].trim() : '';
                    console.log(`üìù Contenu supprim√©: "${deletedContent}"`);

                    const removed = this.removeMessageByTwitchId(twitchMsgId);

                    if (removed) {
                        console.log(`‚úÖ Message supprim√© avec succ√®s: ${twitchMsgId}`);
                    } else {
                        console.log(`‚ùå Message non trouv√© dans le stockage: ${twitchMsgId}`);
                    }

                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement CLEARMSG:', error);
                }
            }

            handleClearChat(rawMessage) {
                try {
                    console.log('üõ°Ô∏è CLEARCHAT d√©tect√©:', rawMessage);

                    const targetMatch = rawMessage.match(/CLEARCHAT #\w+ :(.+)/);
                    if (!targetMatch) return;

                    const targetUsername = targetMatch[1].trim();
                    console.log(`üéØ Utilisateur cibl√© par CLEARCHAT: ${targetUsername}`);

                    if (targetUsername && targetUsername !== '') {
                        this.removeMessagesByUsername(targetUsername);
                        console.log(`üóëÔ∏è Messages de ${targetUsername} supprim√©s (ban/timeout)`);
                    } else {
                        console.log('üìù CLEARCHAT sans utilisateur - possible suppression de message');
                    }

                    const msgIdMatch = rawMessage.match(/target-msg-id=([^;]*)/);
                    if (msgIdMatch && msgIdMatch[1]) {
                        const twitchMsgId = msgIdMatch[1];
                        console.log(`üÜî ID du message supprim√©: ${twitchMsgId}`);
                        this.removeMessageByTwitchId(twitchMsgId);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement CLEARCHAT:', error);
                }
            }

            handleUserNotice(rawMessage) {
                try {
                    console.log('üì¢ USERNOTICE d√©tect√©:', rawMessage);

                    if (rawMessage.includes('msg-id=delete')) {
                        console.log('üóëÔ∏è Suppression de message d√©tect√©e');
                        const msgIdMatch = rawMessage.match(/msg-id=delete_(\w+)/);
                        if (msgIdMatch) {
                            const msgId = msgIdMatch[1];
                            console.log(`üéØ ID du message supprim√©: ${msgId}`);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement USERNOTICE:', error);
                }
            }

            removeMessageByContent(username, content) {
                let removedCount = 0;
                const usernameLower = username.toLowerCase();
                const contentLower = content.toLowerCase();

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.username.toLowerCase() === usernameLower &&
                        messageData.text.toLowerCase().includes(contentLower)) {
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }

                        this.messages.delete(messageId);
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Supprim√© ${removedCount} messages de ${username} avec contenu similaire`);
                    return true;
                }
                return false;
            }

            removeMessageByTwitchId(twitchMessageId) {
                let removedCount = 0;

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.twitchMessageId === twitchMessageId) {
                        console.log(`üéØ Message trouv√© par ID Twitch: ${twitchMessageId}, supprim√©`);

                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }

                        this.messages.delete(messageId);
                        removedCount++;
                        break;
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Message supprim√© par ID Twitch: ${twitchMessageId}`);
                    return true;
                } else {
                    console.log(`‚ùå Aucun message trouv√© avec l'ID Twitch: ${twitchMessageId}`);
                    return false;
                }
            }



                        async parseIRCMessage(rawMessage) {
                if (this.debugMode) {
                    const timestamp = new Date().toISOString();
                    const logEntry = {
                        timestamp: timestamp,
                        rawMessage: rawMessage,
                        type: this.detectIRCMessageType(rawMessage)
                    };

                    this.ircMessageLog.push(logEntry);

                    if (this.ircMessageLog.length > 100) {
                        this.ircMessageLog.shift();
                    }

                    console.log(`üîç IRC DEBUG [${logEntry.type}]: ${rawMessage}`);
                }

                if (rawMessage.includes('CLEARMSG')) {
                    this.handleClearMsg(rawMessage);
                    return;
                }

                if (rawMessage.includes('CLEARCHAT')) {
                    this.handleClearChat(rawMessage);
                    return;
                }

                if (rawMessage.includes('USERNOTICE')) {
                    this.handleUserNotice(rawMessage);
                    return;
                }

                if (!rawMessage.includes('PRIVMSG')) return;

                try {
                    console.log('Message brut IRC:', rawMessage);

                    let username = 'Anonyme';

                    const privmsgMatch = rawMessage.match(/\s:([^!]+)![^@]+@[^\.]+\.tmi\.twitch\.tv\s+PRIVMSG/);
                    if (privmsgMatch) {
                        username = privmsgMatch[1];
                    } else {
                        const displayNameMatch = rawMessage.match(/display-name=([^;]*)/);
                        if (displayNameMatch && displayNameMatch[1]) {
                            username = displayNameMatch[1];
                        } else {
                            const fallbackMatch = rawMessage.match(/:([^!]+)!/);
                            if (fallbackMatch) {
                                username = fallbackMatch[1];
                            }
                        }
                    }

                    const roomIdMatch = rawMessage.match(/room-id=(\d+)/);
                    const roomId = roomIdMatch ? roomIdMatch[1] : null;
                    console.log(`üè† Room ID d√©tect√©: ${roomId}`);

                    let channelInfo = null;
                    if (roomId) {
                        channelInfo = await this.getChannelInfo(roomId);
                        if (channelInfo) {
                            console.log(`üè¢ Cha√Æne d'origine: ${channelInfo.displayName}`);
                        }
                    }


                    let twitchEmotes = null;
                    const emotesMatch = rawMessage.match(/emotes=([^;]*)/);
                    if (emotesMatch && emotesMatch[1] && emotesMatch[1] !== '') {
                        twitchEmotes = emotesMatch[1];
                    }

                    const privmsgPattern = `PRIVMSG #${this.channel} :`;
                    const privmsgIndex = rawMessage.indexOf(privmsgPattern);
                    let messageText = '';

                    if (privmsgIndex !== -1) {
                        messageText = rawMessage.substring(privmsgIndex + privmsgPattern.length);
                        messageText = messageText.replace(/\r\n?|\n/g, '');
                    }

                    const badges = this.extractBadges(rawMessage);

                    let userColor = null;
                    try {
                        userColor = this.extractUserColor(rawMessage);
                    } catch (error) {
                        userColor = null;
                    }

                    let twitchMessageId = null;
                    const messageIdMatch = rawMessage.match(/id=([^;]*)/);
                    if (messageIdMatch && messageIdMatch[1]) {
                        twitchMessageId = messageIdMatch[1];
                        console.log(`üÜî ID du message Twitch: ${twitchMessageId}`);
                    }

                    console.log('Message pars√©:', { username, messageText, badges, twitchEmotes, userColor, channelInfo, twitchMessageId });

                    if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh'))) {
                        const commandHandled = this.handleChatCommand(username, messageText);
                        if (commandHandled) {
                            return;
                        }
                    }

                    if (messageText.trim()) {
                        this.addMessage({
                            nick: username,
                            text: messageText,
                            badges: badges,
                            twitchEmotes: twitchEmotes,
                            userColor: userColor,
                            originChannel: channelInfo,
                            twitchMessageId: twitchMessageId
                        });
                    }
                } catch (error) {
                }
            }

            async loadSevenTVEmotes() {
                try {
                    const globalResponse = await fetch('https://7tv.io/v3/emote-sets/global');

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();

                        if (globalData.emotes && Array.isArray(globalData.emotes)) {

                            globalData.emotes.forEach((emote, index) => {
                                if (index < 5) {
                                }

                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.globalSevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 5) {
                                    }
                                } else {
                                    if (index < 5) {
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse globale ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes globales:', globalResponse.status);
                    }

                console.log('üì° R√©cup√©ration des emotes du canal fugu_fps via le set ID...');

                    const setResponse = await fetch('https://7tv.io/v3/emote-sets/01GEG2EPE80006SAE3KT92JGK5');
                    console.log('ÔøΩ R√©ponse set d\'emotes:', setResponse.status, setResponse.statusText);

                    if (setResponse.ok) {
                        const setData = await setResponse.json();
                        console.log('üì¶ Donn√©es du set re√ßues:', setData);

                        if (setData.emotes && Array.isArray(setData.emotes)) {
                            console.log(`üìä Nombre d'emotes du canal trouv√©es: ${setData.emotes.length}`);

                            setData.emotes.forEach((emote, index) => {
                                if (index < 10) {
                                    console.log(`üîç Emote canal ${index}:`, emote);
                                }

                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.sevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 10) {
                                        console.log(`‚úÖ Emote canal ${index} ajout√©e:`, emote.name, urls);
                                    }
                                } else {
                                    if (index < 10) {
                                        console.log(`‚ùå Emote canal ${index} incompl√®te:`, emote);
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse du set ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes du set:', setResponse.status);
                    }

                    console.log(`‚úÖ 7TV emotes charg√©es: ${this.sevenTVEmotes.size} emotes du canal + ${this.globalSevenTVEmotes.size} emotes globales`);

                    if (this.sevenTVEmotes.size > 0) {
                        console.log('üìã Toutes les emotes du canal fugu_fps:', Array.from(this.sevenTVEmotes.keys()).sort());
                    }
                    if (this.globalSevenTVEmotes.size > 0) {
                        console.log('üìã Exemples d\'emotes globales:', Array.from(this.globalSevenTVEmotes.keys()).slice(0, 20));
                    }

                    const testEmotes = ['WHAT', 'LeaClassic', 'Kappa', 'KEKW', 'CDEC', 'EZ'];
                    testEmotes.forEach(emote => {
                        const inChannel = this.sevenTVEmotes.has(emote);
                        const inGlobal = this.globalSevenTVEmotes.has(emote);
                        console.log(`üîé Emote "${emote}" - Canal: ${inChannel}, Global: ${inGlobal}`);

                        if (inChannel) {
                            const emoteData = this.sevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        } else if (inGlobal) {
                            const emoteData = this.globalSevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        }
                    });

                } catch (error) {
                    console.error('üí• Erreur lors du chargement des emotes 7TV:', error);
                    console.error('üìç Stack trace:', error.stack);
                }
            }

            parseSevenTVEmotes(message) {
                if (!message) return message;

                console.log('üîç Parsing 7TV emotes pour:', message);


                const words = message.split(/(\s+)/);
                console.log('üìù Mots d√©tect√©s:', words);

                for (let i = 0; i < words.length; i++) {
                    let word = words[i].trim();
                    if (!word) continue;


                    let emoteFound = false;
                    let emoteData = null;

                    if (this.sevenTVEmotes.has(word)) {
                        emoteData = this.sevenTVEmotes.get(word);
                        emoteFound = true;
                    }
                    else if (this.globalSevenTVEmotes.has(word)) {
                        emoteData = this.globalSevenTVEmotes.get(word);
                        emoteFound = true;
                    }

                    if (emoteFound && emoteData && emoteData.urls && Array.isArray(emoteData.urls)) {
                        const imageUrl = emoteData.urls.find(url => url.includes('2x.webp')) ||
                                        emoteData.urls.find(url => url.includes('1x.webp')) ||
                                        emoteData.urls[0];

                        if (imageUrl) {
                            const fullUrl = imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl;
                            const emoteImg = `<img class="emote-7tv" src="${fullUrl}" alt="${word}" title="${word}">`;
                            words[i] = words[i].replace(word, emoteImg);
                        } else {
                        }
                    } else {
                        if (word.length > 2) {
                        }
                    }

                    if (word === 'LeaClassic') {

                        if (this.sevenTVEmotes.has('LeaClassic')) {
                            const emote = this.sevenTVEmotes.get('LeaClassic');
                        }

                        const similarEmotes = [];
                        this.sevenTVEmotes.forEach((emote, name) => {
                            if (name.toLowerCase().includes('lea') || name.toLowerCase().includes('classic')) {
                                similarEmotes.push(name);
                            }
                        });
                    }
                }

                const parsedMessage = words.join('');

                if (parsedMessage !== message) {
                    console.log('üèÅ Message apr√®s parsing emotes:', parsedMessage);
                }

                return parsedMessage;
            }

            parseTwitchEmotes(message, emoteData) {
                if (!message || !emoteData) return message;

                // console.log('üü£ Parsing emotes Twitch pour:', message);
                // console.log('üü£ Donn√©es emotes Twitch:', emoteData);

                let result = message;

                // Parser les emotes Twitch depuis les tags IRC
                // Format: emote_id:start_pos-end_pos,start_pos-end_pos/emote_id:start_pos-end_pos
                const emoteEntries = emoteData.split('/');

                // Collecter toutes les positions d'emotes pour les traiter en ordre inverse
                const emoteReplacements = [];

                emoteEntries.forEach(entry => {
                    const [emoteId, positions] = entry.split(':');
                    if (!emoteId || !positions) return;

                    const positionPairs = positions.split(',');
                    positionPairs.forEach(pair => {
                        const [start, end] = pair.split('-').map(Number);
                        if (isNaN(start) || isNaN(end)) return;

                        const emoteName = message.substring(start, end + 1);
                        emoteReplacements.push({
                            start,
                            end: end + 1,
                            emoteId,
                            emoteName
                        });
                    });
                });

                // Trier par position de fin en ordre d√©croissant pour remplacer de droite √† gauche
                emoteReplacements.sort((a, b) => b.start - a.start);

                emoteReplacements.forEach(replacement => {
                    const { start, end, emoteId, emoteName } = replacement;
                    const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/2.0`;
                    const emoteImg = `<img class="emote-twitch" src="${emoteUrl}" alt="${emoteName}" title="${emoteName}" style="width: 28px; height: 28px; vertical-align: middle; margin: 0 2px;">`;

                    result = result.substring(0, start) + emoteImg + result.substring(end);
                    console.log(`üü£ Emote Twitch remplac√©e: "${emoteName}" ‚Üí ${emoteUrl}`);
                });

                return result;
            }

            extractBadges(rawMessage) {
                const badges = {};

                // Extraire les badges depuis les tags IRC (format Twitch)
                if (rawMessage.includes('badges=')) {
                    const badgeMatch = rawMessage.match(/badges=([^;]*)/);
                    if (badgeMatch && badgeMatch[1]) {
                        const badgeList = badgeMatch[1].split(',');
                        badgeList.forEach(badge => {
                            const [type, version] = badge.split('/');
                            if (type === 'moderator') {
                                badges.moderator = true;
                                badges.moderatorVersion = version;
                            }
                            if (type === 'vip') {
                                badges.vip = true;
                                badges.vipVersion = version;
                            }
                            if (type === 'subscriber') {
                                badges.subscriber = true;
                                badges.subscriberVersion = version;
                            }
                            if (type === 'broadcaster') {
                                badges.broadcaster = true;
                                badges.broadcasterVersion = version;
                            }
                            if (type === 'predictions') {
                                badges.predictions = true;
                                badges.predictionsVersion = version;
                            }
                            if (type === 'bits') {
                                badges.bits = true;
                                badges.bitsVersion = version;
                            }
                            if (type === 'sub-gifter') {
                                badges.subGifter = true;
                                badges.subGifterVersion = version;
                            }
                            if (type === 'sub-gift-leader') {
                                badges.subGiftLeader = true;
                                badges.subGiftLeaderVersion = version;
                            }
                            if (type === 'bits-leader') {
                                badges.bitsLeader = true;
                                badges.bitsLeaderVersion = version;
                            }
                            if (type === 'clips-leader') {
                                badges.clipsLeader = true;
                                badges.clipsLeaderVersion = version;
                            }
                            if (type === 'premium') {
                                badges.premium = true;
                                badges.premiumVersion = version;
                            }
                            if (type === 'turbo') {
                                badges.turbo = true;
                                badges.turboVersion = version;
                            }
                            if (type === 'verified') {
                                badges.verified = true;
                                badges.verifiedVersion = version;
                            }
                            if (type === 'partner') {
                                badges.partner = true;
                                badges.partnerVersion = version;
                            }
                            if (type === 'prime') {
                                badges.prime = true;
                                badges.primeVersion = version;
                            }
                            if (type === 'no-audio' || type === 'no_audio') {
                                badges.noAudio = true;
                                badges.noAudioVersion = version;
                            }
                            if (type === 'no-video' || type === 'no_video') {
                                badges.noVideo = true;
                                badges.noVideoVersion = version;
                            }
                            if (type === 'dj') {
                                badges.dj = true;
                                badges.djVersion = version;
                            }
                            if (type === 'ambassador') {
                                badges.ambassador = true;
                                badges.ambassadorVersion = version;
                            }
                            if (type === 'anonymous-cheerer') {
                                badges.anonymousCheerer = true;
                                badges.anonymousCheererVersion = version;
                            }
                            if (type === 'artist-badge') {
                                badges.artist = true;
                                badges.artistVersion = version;
                            }
                            // Badges sp√©ciaux/√©v√©nements
                            if (type.includes('game-award') || type.includes('twitchcon') || type.includes('recap') || type.includes('zevent') || type.includes('pixel-heart') || type.includes('arcane') || type.includes('lol') || type.includes('rplace') || type.includes('glhf') || type.includes('glitchcon') || type.includes('share-the-love') || type.includes('subtember') || type.includes('raging-wolf') || type.includes('gone-bananas') || type.includes('speedons') || type.includes('elden-ring')) {
                                badges.special = true;
                                badges.specialType = type;
                                badges.specialVersion = version;
                            }
                        });
                    }
                }

                return badges;
            }

            extractUserColor(rawMessage) {
                // Extraire la couleur depuis les tags IRC (format: color=#FF4500)
                const colorMatch = rawMessage.match(/color=([^;]*)/);
                console.log('üîç Recherche de couleur dans:', rawMessage.substring(0, 200) + '...');
                console.log('üîç Match couleur trouv√©:', colorMatch);

                if (colorMatch) {
                    const color = colorMatch[1];
                    console.log('üé® Couleur brute extraite:', `"${color}" (longueur: ${color ? color.length : 0})`);

                    if (color && color !== '' && color.trim() !== '') {
                        // V√©rifier que c'est une couleur valide (commence par # et a 6 caract√®res hexad√©cimaux)
                        if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                            console.log(`‚úÖ Couleur utilisateur extraite valide: ${color}`);
                            return color;
                        } else {
                            console.log(`‚ùå Couleur invalide (format incorrect): "${color}"`);
                        }
                    } else {
                        console.log(`‚ùå Couleur vide d√©tect√©e: "${color}"`);
                    }
                } else {
                    console.log('‚ùå Aucun match trouv√© pour color= dans les tags');
                }

                // Si pas de couleur ou couleur invalide, retourner null pour utiliser le syst√®me de fallback
                console.log('‚ö™ Pas de couleur utilisateur valide, utilisation du syst√®me de fallback');
                return null;
            }

            initStreamlabsEvents() {
                // √âcouter les √©v√©nements de chat de Streamlabs OBS (en backup)
                window.addEventListener('onEventReceived', (obj) => {
                    if (obj.detail.event && obj.detail.event.type === 'message') {
                        // V√©rifier et traiter les commandes de chat
                        const eventData = obj.detail.event.data;
                        const username = eventData.nick || eventData.username || 'Utilisateur';
                        const messageText = eventData.text || eventData.message || '';

                        if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh'))) {
                            const commandHandled = this.handleChatCommand(username, messageText);
                            if (commandHandled) {
                                console.log(`‚úÖ Commande Streamlabs trait√©e par ${username}: ${messageText}`);
                                return; // Ne pas afficher la commande dans le chat
                            }
                        }

                        this.addMessage(eventData);
                    }
                });

                // Pour les tests avec StreamElements (alternative)
                window.addEventListener('onWidgetLoad', (obj) => {
                    console.log('Widget charg√© pour fugu_fps');
                });

                console.log('Widget de chat initialis√© pour fugu_fps');
            }

            getUserColor(username) {
                if (!this.userColors.has(username)) {
                    this.userColors.set(username, this.colors[this.colorIndex % this.colors.length]);
                    this.colorIndex++;
                }
                return this.userColors.get(username);
            }

            getUserBadgeClass(badges) {
                if (!badges) return '';

                if (badges.moderator) return 'moderator';
                if (badges.vip) return 'vip';
                if (badges.subscriber) return 'subscriber';
                if (badges.predictions) return 'predictions';
                if (badges.partner) return 'partner';
                if (badges.premium || badges.prime) return 'premium';

                return '';
            }

            cleanMessage(text) {
                // Nettoyer le message des caract√®res sp√©ciaux et balises (mais garder les emotes)
                // Supprimer les caract√®res de contr√¥le IRC (notamment \u0001 pour ACTION)
                return text
                    .replace(/\u0001ACTION\s*/g, '') // Supprimer \u0001ACTION au d√©but
                    .replace(/\u0001/g, '') // Supprimer tous les autres \u0001
                    .replace(/\r\n?|\n/g, '') // Supprimer les retours √† la ligne
                    .trim();
            }

            addMessage(data) {
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message';

                // Generate unique message ID
                const messageId = this.generateMessageId();
                messageElement.setAttribute('data-message-id', messageId);

                const username = data.nick || data.username || 'Utilisateur';
                let message = this.cleanMessage(data.text || data.message || '');

                // Parser les emotes Twitch en premier (priorit√© aux emotes natives)
                if (data.twitchEmotes) {
                    message = this.parseTwitchEmotes(message, data.twitchEmotes);
                }

                // Ensuite parser les emotes 7TV sur le texte restant
                message = this.parseSevenTVEmotes(message);

                // D√©terminer la couleur - priorit√© √† la couleur utilisateur
                let userColor = '';
                console.log(`üîç Debug couleur pour ${username}:`, {
                    userColorFromData: data.userColor,
                    hasUserColor: !!data.userColor
                });

                if (data.userColor) {
                    // Utiliser la couleur choisie par l'utilisateur
                    userColor = `style="color: ${data.userColor} !important;"`;
                    console.log(`üé® Utilisation de la couleur utilisateur: ${data.userColor} pour ${username}`);
                } else {
                    // Syst√®me de fallback avec couleurs pr√©d√©finies
                    userColor = `class="${this.getUserColor(username)}"`;
                    console.log(`üé≤ Utilisation de la couleur al√©atoire pour ${username}`);
                }

                const badgeClass = this.getUserBadgeClass(data.badges);

                // Cr√©er l'affichage des badges avec l'API Twitch et fallback local
                let badgeDisplay = '';
                if (data.badges) {
                    if (data.badges.broadcaster) {
                        const badgeUrl = this.getBadgeUrl('broadcaster', data.badges.broadcasterVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Broadcaster" title="Broadcaster">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="broadcaster.png" alt="Broadcaster" title="Broadcaster" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/1'">`;
                        }
                    }
                    if (data.badges.moderator) {
                        const badgeUrl = this.getBadgeUrl('moderator', data.badges.moderatorVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Moderator" title="Moderator">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="moderator.png" alt="Moderator" title="Moderator" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                        }
                    }
                    if (data.badges.vip) {
                        const badgeUrl = this.getBadgeUrl('vip', data.badges.vipVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="VIP" title="VIP">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="vip.png" alt="VIP" title="VIP" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/1'">`;
                        }
                    }
                    if (data.badges.subscriber) {
                        // Essayer d'abord l'API Twitch, puis fallback local
                        const subVersion = data.badges.subscriberVersion || '0';
                        const badgeUrl = this.getBadgeUrl('subscriber', subVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Subscriber ${subVersion}" title="Abonn√© ${subVersion} mois">`;
                        } else {
                            // Fallback local avec mapping des versions
                            let subBadgeFile = '';

                            // Mapper les versions aux noms de fichiers
                            switch(subVersion) {
                                case '0':
                                case '1':
                                    subBadgeFile = '1-mois.png';
                                    break;
                                case '2':
                                    subBadgeFile = '2-mois.png';
                                    break;
                                case '3':
                                    subBadgeFile = '3-mois.png';
                                    break;
                                case '6':
                                    subBadgeFile = '6-mois.png';
                                    break;
                                case '9':
                                    subBadgeFile = '9-mois.png';
                                    break;
                                case '12':
                                    subBadgeFile = '1-an.png';
                                    break;
                                case '18':
                                    subBadgeFile = '18-mois.png';
                                    break;
                                case '24':
                                    subBadgeFile = '2-ans.png';
                                    break;
                                default:
                                    // Pour les versions non pr√©vues, utiliser le badge 1 mois
                                    subBadgeFile = '1-mois.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${subBadgeFile}" alt="Subscriber ${subVersion}" title="Abonn√© ${subVersion} mois" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/1'">`;
                        }
                    }
                    if (data.badges.predictions) {
                        // Essayer d'abord l'API Twitch, puis fallback local
                        const predVersion = data.badges.predictionsVersion || '1';
                        const badgeUrl = this.getBadgeUrl('predictions', predVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Prediction ${predVersion}" title="Pr√©diction ${predVersion}">`;
                        } else {

                            let predBadgeFile = '';

                            // Mapper les versions de pr√©diction aux fichiers
                            switch(predVersion) {
                                case '1':
                                case 'blue-1':
                                    predBadgeFile = 'predi-1.png';
                                    break;
                                case '2':
                                case 'pink-2':
                                    predBadgeFile = 'predi-2.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser predi-1
                                    predBadgeFile = 'predi-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${predBadgeFile}" alt="Prediction ${predVersion}" title="Pr√©diction ${predVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/73e8b446-2ca8-4dc7-912c-e35fc11d1c4e/1'">`;
                        }
                    }
                    // Badges Bits/Cheers
                    if (data.badges.bits) {
                        const bitsVersion = data.badges.bitsVersion || '1';
                        const badgeUrl = this.getBadgeUrl('bits', bitsVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Bits ${bitsVersion}" title="Bits ${bitsVersion}">`;
                        } else {
                            // Fallback local avec mapping des niveaux
                            let bitsBadgeFile = '';

                            // Mapper les niveaux de bits aux fichiers
                            if (parseInt(bitsVersion) >= 5000000) bitsBadgeFile = 'cheer-5000000.png';
                            else if (parseInt(bitsVersion) >= 4500000) bitsBadgeFile = 'cheer-4500000.png';
                            else if (parseInt(bitsVersion) >= 4000000) bitsBadgeFile = 'cheer-4000000.png';
                            else if (parseInt(bitsVersion) >= 3500000) bitsBadgeFile = 'cheer-3500000.png';
                            else if (parseInt(bitsVersion) >= 3000000) bitsBadgeFile = 'cheer-3000000.png';
                            else if (parseInt(bitsVersion) >= 2500000) bitsBadgeFile = 'cheer-2500000.png';
                            else if (parseInt(bitsVersion) >= 2000000) bitsBadgeFile = 'cheer-2000000.png';
                            else if (parseInt(bitsVersion) >= 1750000) bitsBadgeFile = 'cheer-1750000.png';
                            else if (parseInt(bitsVersion) >= 1500000) bitsBadgeFile = 'cheer-1500000.png';
                            else if (parseInt(bitsVersion) >= 1250000) bitsBadgeFile = 'cheer-1250000.png';
                            else if (parseInt(bitsVersion) >= 1000000) bitsBadgeFile = 'cheer-1000000.png';
                            else if (parseInt(bitsVersion) >= 900000) bitsBadgeFile = 'cheer-900000.png';
                            else if (parseInt(bitsVersion) >= 800000) bitsBadgeFile = 'cheer-800000.png';
                            else if (parseInt(bitsVersion) >= 750000) bitsBadgeFile = 'cheer-750000.png';
                            else if (parseInt(bitsVersion) >= 700000) bitsBadgeFile = 'cheer-700000.png';
                            else if (parseInt(bitsVersion) >= 600000) bitsBadgeFile = 'cheer-600000.png';
                            else if (parseInt(bitsVersion) >= 500000) bitsBadgeFile = 'cheer-500000.png';
                            else if (parseInt(bitsVersion) >= 400000) bitsBadgeFile = 'cheer-400000.png';
                            else if (parseInt(bitsVersion) >= 300000) bitsBadgeFile = 'cheer-300000.png';
                            else if (parseInt(bitsVersion) >= 200000) bitsBadgeFile = 'cheer-200000.png';
                            else if (parseInt(bitsVersion) >= 100000) bitsBadgeFile = 'cheer-100000.png';
                            else if (parseInt(bitsVersion) >= 50000) bitsBadgeFile = 'cheer-50000.png';
                            else if (parseInt(bitsVersion) >= 25000) bitsBadgeFile = 'cheer-25000.png';
                            else if (parseInt(bitsVersion) >= 10000) bitsBadgeFile = 'cheer-10000.png';
                            else if (parseInt(bitsVersion) >= 5000) bitsBadgeFile = 'cheer-5000.png';
                            else if (parseInt(bitsVersion) >= 1000) bitsBadgeFile = 'cheer-1000.png';
                            else if (parseInt(bitsVersion) >= 100) bitsBadgeFile = 'cheer-100.png';
                            else bitsBadgeFile = 'cheer-1.png';

                            badgeDisplay += `<img class="badge-image" src="${bitsBadgeFile}" alt="Bits ${bitsVersion}" title="Bits ${bitsVersion}">`;
                        }
                    }
                    // Badges Sub Gift Leader
                    if (data.badges.subGiftLeader) {
                        const giftLeaderVersion = data.badges.subGiftLeaderVersion || '1';
                        const badgeUrl = this.getBadgeUrl('sub-gift-leader', giftLeaderVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Gift Leader ${giftLeaderVersion}" title="Gift Leader ${giftLeaderVersion}">`;
                        } else {
                            // Fallback local
                            let gifterBadgeFile = '';

                            // Les gift leaders utilisent les fichiers gifter-1.png, gifter-2.png, gifter-3.png
                            switch(giftLeaderVersion) {
                                case '1':
                                    gifterBadgeFile = 'gifter-1.png';
                                    break;
                                case '2':
                                    gifterBadgeFile = 'gifter-2.png';
                                    break;
                                case '3':
                                    gifterBadgeFile = 'gifter-3.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser gifter-1.png pour niveau 1
                                    gifterBadgeFile = 'gifter-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${gifterBadgeFile}" alt="Gift Leader ${giftLeaderVersion}" title="Gift Leader ${giftLeaderVersion}">`;
                        }
                    }
                    // Badges Sub Gifter (utilise les fichiers sub-gift-X.png pour les quantit√©s)
                    else if (data.badges.subGifter) {
                        const giftVersion = data.badges.subGifterVersion || '1';
                        const badgeUrl = this.getBadgeUrl('sub-gifter', giftVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Sub Gifter ${giftVersion}" title="Sub Gifter ${giftVersion}">`;
                        } else {
                            // Fallback local
                            let giftBadgeFile = '';

                            if (parseInt(giftVersion) >= 5000) giftBadgeFile = 'sub-gift-5000.png';
                            else if (parseInt(giftVersion) >= 4000) giftBadgeFile = 'sub-gift-4000.png';
                            else if (parseInt(giftVersion) >= 3000) giftBadgeFile = 'sub-gift-3000.png';
                            else if (parseInt(giftVersion) >= 2000) giftBadgeFile = 'sub-gift-2000.png';
                            else if (parseInt(giftVersion) >= 1000) giftBadgeFile = 'sub-gift-1000.png';
                            else if (parseInt(giftVersion) >= 950) giftBadgeFile = 'sub-gift-950.png';
                            else if (parseInt(giftVersion) >= 900) giftBadgeFile = 'sub-gift-900.png';
                            else if (parseInt(giftVersion) >= 850) giftBadgeFile = 'sub-gift-850.png';
                            else if (parseInt(giftVersion) >= 800) giftBadgeFile = 'sub-gift-800.png';
                            else if (parseInt(giftVersion) >= 750) giftBadgeFile = 'sub-gift-750.png';
                            else if (parseInt(giftVersion) >= 700) giftBadgeFile = 'sub-gift-700.png';
                            else if (parseInt(giftVersion) >= 650) giftBadgeFile = 'sub-gift-650.png';
                            else if (parseInt(giftVersion) >= 600) giftBadgeFile = 'sub-gift-600.png';
                            else if (parseInt(giftVersion) >= 550) giftBadgeFile = 'sub-gift-550.png';
                            else if (parseInt(giftVersion) >= 500) giftBadgeFile = 'sub-gift-500.png';
                            else if (parseInt(giftVersion) >= 450) giftBadgeFile = 'sub-gift-450.png';
                            else if (parseInt(giftVersion) >= 400) giftBadgeFile = 'sub-gift-400.png';
                            else if (parseInt(giftVersion) >= 350) giftBadgeFile = 'sub-gift-350.png';
                            else if (parseInt(giftVersion) >= 300) giftBadgeFile = 'sub-gift-300.png';
                            else if (parseInt(giftVersion) >= 250) giftBadgeFile = 'sub-gift-250.png';
                            else if (parseInt(giftVersion) >= 200) giftBadgeFile = 'sub-gift-200.png';
                            else if (parseInt(giftVersion) >= 150) giftBadgeFile = 'sub-gift-150.png';
                            else if (parseInt(giftVersion) >= 100) giftBadgeFile = 'sub-gift-100.png';
                            else if (parseInt(giftVersion) >= 50) giftBadgeFile = 'sub-gift-50.png';
                            else if (parseInt(giftVersion) >= 25) giftBadgeFile = 'sub-gift-25.png';
                            else if (parseInt(giftVersion) >= 10) giftBadgeFile = 'sub-gift-10.png';
                            else if (parseInt(giftVersion) >= 5) giftBadgeFile = 'sub-gift-5.png';
                            else giftBadgeFile = 'sub-gift-1.png';

                            badgeDisplay += `<img class="badge-image" src="${giftBadgeFile}" alt="Sub Gifter ${giftVersion}" title="Sub Gifter ${giftVersion}">`;
                        }
                    }
                    // Badges Clips Leader
                    if (data.badges.clipsLeader) {
                        const clipsVersion = data.badges.clipsLeaderVersion || '1';
                        const badgeUrl = this.getBadgeUrl('clips-leader', clipsVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Clips Leader ${clipsVersion}" title="Clips Leader ${clipsVersion}">`;
                        } else {
                            // Fallback local
                            let clipsBadgeFile = '';

                            // Mapper les niveaux de clips aux fichiers
                            switch(clipsVersion) {
                                case '1':
                                    clipsBadgeFile = 'clipe-1.png';
                                    break;
                                case '2':
                                    clipsBadgeFile = 'clipe-2.png';
                                    break;
                                case '3':
                                    clipsBadgeFile = 'clipe-3.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser clipe-1
                                    clipsBadgeFile = 'clipe-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${clipsBadgeFile}" alt="Clips Leader ${clipsVersion}" title="Clips Leader ${clipsVersion}">`;
                        }
                    }
                    // Badge Prime/Premium
                    if (data.badges.prime || data.badges.premium) {
                        badgeDisplay += `<img class="badge-image" src="prime.png" alt="Prime" title="Prime Gaming">`;
                    }
                    // Badge Turbo
                    if (data.badges.turbo) {
                        badgeDisplay += `<img class="badge-image" src="turbo.png" alt="Turbo" title="Turbo">`;
                    }
                    // Badge Verified
                    if (data.badges.verified) {
                        badgeDisplay += `<img class="badge-image" src="verified.png" alt="Verified" title="Verified">`;
                    }
                    if (data.badges.partner) {
                        badgeDisplay += `<img class="badge-image" src="verified.png" alt="Verified" title="Verified">`;
                    }
                    // Badge No Audio (listen only)
                    if (data.badges.noAudio) {
                        badgeDisplay += `<img class="badge-image" src="no-audio.png" alt="No Audio" title="Audio d√©sactiv√© - √âcoute uniquement">`;
                    }
                    // Badge No Video (listen only)
                    if (data.badges.noVideo) {
                        badgeDisplay += `<img class="badge-image" src="listen.png" alt="Listen Only" title="√âcoute uniquement - Pas de vid√©o">`;
                    }
                    // Badge DJ
                    if (data.badges.dj) {
                        badgeDisplay += `<img class="badge-image" src="dj.png" alt="DJ" title="Twitch DJ">`;
                    }
                    // Badge Ambassador
                    if (data.badges.ambassador) {
                        badgeDisplay += `<img class="badge-image" src="ambassador.png" alt="Ambassador" title="Twitch Ambassador">`;
                    }
                    // Badge Anonymous Cheerer
                    if (data.badges.anonymousCheerer) {
                        badgeDisplay += `<img class="badge-image" src="anonymous-cheerer.png" alt="Anonymous Cheerer" title="Cheerer Anonyme">`;
                    }
                    // Badge Artist
                    if (data.badges.artist) {
                        badgeDisplay += `<img class="badge-image" src="Artist.png" alt="Artist" title="Artiste">`;
                    }
                    // Badges sp√©ciaux/√©v√©nements
                    if (data.badges.special) {
                        const specialType = data.badges.specialType;
                        let specialBadgeFile = '';

                        // Mapper les badges sp√©ciaux
                        if (specialType.includes('game-award-2023')) specialBadgeFile = 'game-award-2023.png';
                        else if (specialType.includes('golden-predictor-game-award-2023')) specialBadgeFile = 'golden-predictor-game-award-2023.png';
                        else if (specialType.includes('twitchcon-2025')) specialBadgeFile = 'twitchcon-2025.png';
                        else if (specialType.includes('twitchrecap-2024') || specialType.includes('twitch-recap-2024')) specialBadgeFile = 'twitch-recap-2024.png';
                        else if (specialType.includes('twitch-recap-2023') || specialType.includes('twitchrecap-2023')) specialBadgeFile = 'twitch-recap-2023.png';
                        else if (specialType.includes('twitch-inter-2023')) specialBadgeFile = 'twitch-inter-2023.png';
                        else if (specialType.includes('zevent-2024')) specialBadgeFile = 'zevent-2024.png';
                        else if (specialType.includes('subtember-2024')) specialBadgeFile = 'subtember-2024.png';
                        else if (specialType.includes('lol-mid-season-2025-support')) specialBadgeFile = 'lol-mid-season-2025-support-a-streamer.png';
                        else if (specialType.includes('lol-mid-season-2025')) specialBadgeFile = 'lol-mid-season-2025.png';
                        else if (specialType.includes('premiere-arcane-2') || specialType.includes('arcane-season-2-premiere')) specialBadgeFile = 'premiere-arcane-2.png';
                        else if (specialType.includes('rplace-cake-2023') || specialType.includes('rplace-2023')) specialBadgeFile = 'rplace-cake-2023.png';
                        else if (specialType.includes('share-the-love')) specialBadgeFile = 'share-the-love.png';
                        else if (specialType.includes('gold-pixel-hear-2024')) specialBadgeFile = 'gold-pixel-hear-2024.png';
                        else if (specialType.includes('purple-pixel-hear-2024') || specialType.includes('purple-pixel-heart---together-for-good-24')) specialBadgeFile = 'purple-pixel-heart-2024.png';
                        else if (specialType.includes('ruby-pixel-heart-2024')) specialBadgeFile = 'ruby-pixel-heart-2024.png';
                        else if (specialType.includes('clip-the-hall')) specialBadgeFile = 'clip-the-hall.png';
                        else if (specialType.includes('raging-wolf')) specialBadgeFile = 'raging-wolf.png';
                        else if (specialType.includes('gone-bananas')) specialBadgeFile = 'banana.png';
                        else if (specialType.includes('speedons-5-badge') || specialType.includes('speedons')) specialBadgeFile = 'speedons-5.png';
                        else if (specialType.includes('elden-ring-wylder')) specialBadgeFile = 'elden-ring-wylder.png';
                        else if (specialType.includes('elden-ring-recluse')) specialBadgeFile = 'elden-ring-recluse.png';
                        else if (specialType.includes('glhf') || specialType.includes('GLHF')) specialBadgeFile = 'GLHF.png';
                        else if (specialType.includes('glitchcon') || specialType.includes('Glitchcon')) specialBadgeFile = 'Glitchcon.png';

                        if (specialBadgeFile) {
                            badgeDisplay += `<img class="badge-image" src="${specialBadgeFile}" alt="${specialType}" title="${specialType}">`;
                        }
                    }
                }

                // Cr√©er l'image de la cha√Æne d'origine si disponible ET si le chat partag√© est actif
                let originImageHTML = '';
                if (data.originChannel && data.originChannel.profileImage && this.isSharedChatActive) {
                    console.log(`üè¢ Affichage de l'ic√¥ne de cha√Æne d'origine (chat partag√© actif): ${data.originChannel.displayName}`);
                    originImageHTML = `<img class="badge-image origin-channel" src="${data.originChannel.profileImage}" alt="${data.originChannel.displayName}" title="Cha√Æne d'origine: ${data.originChannel.displayName}" style="width: 22px; height: 22px; border-radius: 4px; margin-right: 6px; object-fit: cover; vertical-align: middle;">`;
                } else if (data.originChannel && data.originChannel.profileImage && !this.isSharedChatActive) {
                    console.log(`üö´ Ic√¥ne de cha√Æne d'origine masqu√©e (chat partag√© inactif): ${data.originChannel.displayName}`);
                }

                messageElement.innerHTML = `
                    <span class="badge-display">
                        ${originImageHTML}
                        ${badgeDisplay}
                    </span>
                    <span class="username ${badgeClass}" ${userColor}>${username}</span>
                    <span class="separator">:</span>
                    <span class="message-content">${message}</span>
                `;

                // Ajouter le message au container
                this.container.appendChild(messageElement);

                // Store message data for potential deletion with Twitch message ID
                this.messages.set(messageId, {
                    id: messageId,
                    username: username,
                    element: messageElement,
                    timestamp: Date.now(),
                    text: message,
                    twitchMessageId: data.twitchMessageId || null, // Store Twitch message ID for moderation
                    originalData: data // Store original data for reference
                });

                // Log message storage for debugging
                if (data.twitchMessageId) {
                    console.log(`üíæ Message stock√©: ID=${messageId}, TwitchID=${data.twitchMessageId}, Username=${username}`);
                }

                // Clean up old messages from storage
                this.cleanupOldMessages();

                // Limiter le nombre de messages
                this.limitMessages();

                // Faire d√©filer vers le bas
                this.scrollToBottom();
            }

            limitMessages() {
                while (this.container.children.length > this.maxMessages) {
                    this.container.removeChild(this.container.firstChild);
                }
            }

            scrollToBottom() {
                this.container.scrollTop = this.container.scrollHeight;
            }

            // Messages de test (√† supprimer en production)
            addTestMessages() {
                setTimeout(() => {
                    const testMessages = [
                        { nick: 'StreamerPro', text: 'Bienvenue dans le stream ! üéÆ', badges: { moderator: true } },
                        { nick: 'ViewerFan', text: 'Salut tout le monde !', badges: { subscriber: true } },
                        { nick: 'GameMaster', text: 'Ce jeu a l\'air vraiment cool, j\'ai h√¢te de voir la suite de cette partie qui s\'annonce √©pique !', badges: { vip: true } },
                        { nick: 'ChatUser', text: 'GG pour ce kill !', badges: {} },
                        { nick: 'FollowerOne', text: 'Premier stream que je regarde et c\'est d√©j√† incroyable, continue comme √ßa !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', badges: {} }
                    ];

                    testMessages.forEach((msg, index) => {
                        setTimeout(() => {
                            this.addMessage(msg);
                        }, index * 2000);
                    });
                }, 1000);
            }
        }

        // Fonction pour v√©rifier si une police est charg√©e en comparant les largeurs de texte
        function isFontLoaded(fontFamily, fallbackFont = 'monospace') {
            const testString = 'mmmmmmmmmmlli';
            const fontSize = '72px';

            // Cr√©er un √©l√©ment avec la police de fallback
            const fallbackElement = document.createElement('div');
            fallbackElement.style.fontFamily = fallbackFont;
            fallbackElement.style.fontSize = fontSize;
            fallbackElement.style.position = 'absolute';
            fallbackElement.style.left = '-9999px';
            fallbackElement.style.top = '-9999px';
            fallbackElement.style.visibility = 'hidden';
            fallbackElement.textContent = testString;
            document.body.appendChild(fallbackElement);

            const fallbackWidth = fallbackElement.offsetWidth;
            document.body.removeChild(fallbackElement);

            // Cr√©er un √©l√©ment avec notre police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = `"${fontFamily}", ${fallbackFont}`;
            testElement.style.fontSize = fontSize;
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.style.top = '-9999px';
            testElement.style.visibility = 'hidden';
            testElement.textContent = testString;
            document.body.appendChild(testElement);

            const testWidth = testElement.offsetWidth;
            document.body.removeChild(testElement);

            const isLoaded = fallbackWidth !== testWidth;
            console.log(`üìê Test de largeur - Fallback: ${fallbackWidth}px, Test: ${testWidth}px, Police charg√©e: ${isLoaded}`);

            return isLoaded;
        }

        // Fonction pour v√©rifier la police charg√©e
        function checkLoadedFonts() {
            console.log('üîç V√©rification des polices charg√©es...');

            // V√©rifier si l'API FontFace est disponible
            if ('fonts' in document) {
                console.log('üìã Toutes les polices charg√©es:', Array.from(document.fonts).map(font => font.family));

                // V√©rifier sp√©cifiquement notre police
                const seaFuguFont = Array.from(document.fonts).find(font =>
                    font.family.includes('Sea Regular Fugu')
                );

                if (seaFuguFont) {
                    console.log('‚úÖ Police "Sea Regular Fugu" trouv√©e:', seaFuguFont);
                    console.log('üìä Status de la police:', seaFuguFont.status);
                } else {
                    console.log('‚ùå Police "Sea Regular Fugu" non trouv√©e dans les polices charg√©es');
                }

                // Utiliser l'API moderne pour v√©rifier le chargement
                document.fonts.check('16px "Sea Regular Fugu"') ?
                    console.log('‚úÖ API fonts.check(): Police "Sea Regular Fugu" charg√©e') :
                    console.log('‚ùå API fonts.check(): Police "Sea Regular Fugu" non charg√©e');
            }

            // Test de largeur pour v√©rifier le chargement
            const fontLoadedByWidth = isFontLoaded('Sea Regular Fugu');

            // V√©rifier la police calcul√©e sur le body
            const bodyElement = document.body;
            const computedStyle = window.getComputedStyle(bodyElement);
            const actualFont = computedStyle.fontFamily;

            console.log('üéØ Police calcul√©e sur le body:', actualFont);

            // Cr√©er un √©l√©ment de test pour v√©rifier la police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = '"Sea Regular Fugu", "Comic Sans MS", "Trebuchet MS", "Arial Black", Arial, sans-serif';
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.textContent = 'Test Font';
            document.body.appendChild(testElement);

            const testComputedStyle = window.getComputedStyle(testElement);
            const testActualFont = testComputedStyle.fontFamily;

            console.log('üß™ Police de test calcul√©e:', testActualFont);

            // Nettoyer l'√©l√©ment de test
            document.body.removeChild(testElement);

            // V√©rifier si la police personnalis√©e est utilis√©e
            if (actualFont.includes('Sea Regular Fugu')) {
                console.log('üéâ SUCCESS: La police "Sea Regular Fugu" est active !');
            } else if (actualFont.includes('Comic Sans MS')) {
                console.log('‚ö†Ô∏è WARNING: Utilisation de la police fallback "Comic Sans MS"');
            } else {
                console.log('‚ùå ERROR: Aucune police reconnue d√©tect√©e. Police actuelle:', actualFont);
            }

            // R√©sum√© final
            console.log('üìù R√âSUM√â:');
            console.log(`   - Police charg√©e (test largeur): ${fontLoadedByWidth ? '‚úÖ' : '‚ùå'}`);
            console.log(`   - Police active dans CSS: ${actualFont.includes('Sea Regular Fugu') ? '‚úÖ' : '‚ùå'}`);
        }

        // Initialiser le widget quand la page est charg√©e
        document.addEventListener('DOMContentLoaded', () => {
            // Cr√©er et exposer le widget globalement pour les tests
            window.chatWidget = new ChatWidget();

            // V√©rifier les polices imm√©diatement
            checkLoadedFonts();

            // √âcouter les √©v√©nements de chargement de polices (API moderne)
            if ('fonts' in document) {
                document.fonts.addEventListener('loadingdone', (event) => {
                    console.log('üéâ √âv√©nement loadingdone d√©clench√© - Polices charg√©es:', event.fontfaces.length);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ${font.family} (${font.status})`);
                    });
                    checkLoadedFonts();
                });

                document.fonts.addEventListener('loadingerror', (event) => {
                    console.log('‚ùå Erreur de chargement de police:', event.fontfaces);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ERREUR: ${font.family} (${font.status})`);
                    });
                });

                // Forcer le chargement de notre police
                document.fonts.load('16px "Sea Regular Fugu"').then(() => {
                    console.log('‚úÖ Police "Sea Regular Fugu" charg√©e explicitement via fonts.load()');
                    checkLoadedFonts();
                }).catch((error) => {
                    console.log('‚ùå Erreur lors du chargement explicite de la police:', error);
                });
            }

            // V√©rifier √† nouveau apr√®s 2 secondes (temps pour que les polices se chargent)
            setTimeout(() => {
                console.log('üîÑ Re-v√©rification des polices apr√®s 2 secondes...');
                checkLoadedFonts();
            }, 2000);

            // V√©rifier une derni√®re fois apr√®s 5 secondes
            setTimeout(() => {
                console.log('üîÑ V√©rification finale des polices apr√®s 5 secondes...');
                checkLoadedFonts();
            }, 5000);
        });

        // Fonction globale pour ajouter des messages manuellement (pour les tests)
        function addTestMessage(username, message, badges = {}) {
            if (window.chatWidget) {
                window.chatWidget.addMessage({
                    nick: username,
                    text: message,
                    badges: badges
                });
            }
        }

        // ===== SECTION DE TEST - SUPPRIMER CETTE SECTION EN PRODUCTION =====
        // Test automatique de chat partag√© toutes les 20 secondes
        /*async function testSharedChatMessage() {
            try {
                const widget = window.chatWidget;
                if (!widget || typeof widget.addMessage !== 'function') {
                    console.error('‚ùå Chat widget not found.');
                    return;
                }

                console.log('üß™ Test de message de chat partag√©...');

                // Manually fetch the channel info for room-id 48624276
                const response = await fetch('https://api.twitch.tv/helix/users?id=48624276', {
                    headers: {
                        'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                        'Authorization': 'Bearer m15k59400wm8tosv4499famn76qpr3'
                    }
                });

                const json = await response.json();
                const originChannel = json.data?.[0]
                    ? {
                        displayName: json.data[0].display_name,
                        login: json.data[0].login,
                        profileImage: json.data[0].profile_image_url
                    }
                    : null;

                widget.addMessage({
                    nick: 'sc0rpio74890',
                    text: 'Ceci est un test simul√© depuis un autre chat partag√©',
                    badges: { vip: true },
                    userColor: '#FF0000FF',
                    originChannel
                });

                console.log('‚úÖ Message de test ajout√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors du test de chat partag√©:', error);
            }
        }

        // ===== FONCTIONS DE TEST DE MOD√âRATION =====
        // Exposer les fonctions de test de mod√©ration globalement
        window.testMessageDeletion = {
            // Tester la suppression par ID Twitch
            testDeleteByTwitchId: function(twitchMessageId) {
                if (window.chatWidget) {
                    console.log(`üß™ Test de suppression par ID Twitch: ${twitchMessageId}`);
                    const result = window.chatWidget.removeMessageByTwitchId(twitchMessageId);
                    console.log(`R√©sultat: ${result ? 'Message supprim√©' : 'Aucun message trouv√©'}`);
                    return result;
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                    return false;
                }
            },

            // Tester la suppression par nom d'utilisateur
            testDeleteByUsername: function(username) {
                if (window.chatWidget) {
                    console.log(`üß™ Test de suppression par nom d'utilisateur: ${username}`);
                    const result = window.chatWidget.removeMessagesByUsername(username);
                    console.log(`R√©sultat: ${result} messages supprim√©s`);
                    return result;
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                    return false;
                }
            },

            // Afficher le statut du stockage
            showStorageStatus: function() {
                if (window.chatWidget) {
                    console.log(`üìä Status du stockage: ${window.chatWidget.messages.size}/50 messages`);
                    console.log('üìã Messages stock√©s:');
                    for (const [id, data] of window.chatWidget.messages.entries()) {
                        console.log(`  - ID: ${id}, User: ${data.username}, TwitchID: ${data.twitchMessageId || 'N/A'}, Text: ${data.text.substring(0, 30)}...`);
                    }
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Simuler un message avec ID Twitch
            addMessageWithTwitchId: function(username, message, twitchId) {
                if (window.chatWidget) {
                    console.log(`üß™ Ajout de message de test avec ID Twitch: ${twitchId}`);
                    window.chatWidget.addMessage({
                        nick: username,
                        text: message,
                        badges: {},
                        twitchMessageId: twitchId
                    });
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Tester le syst√®me de mod√©ration API
            testModerationSystem: function() {
                if (window.chatWidget) {
                    console.log('üß™ Test du syst√®me de mod√©ration API...');
                    window.chatWidget.checkRecentModerations();
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher le cache de mod√©ration
            showModerationCache: function() {
                if (window.chatWidget) {
                    console.log('üõ°Ô∏è Cache de mod√©ration:');
                    for (const [key, data] of window.chatWidget.moderationCache.entries()) {
                        console.log(`  - ${key}: ${data.username} - ${data.reason}`);
                    }
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher tous les messages IRC captur√©s (pour debug)
            showIRCLog: function() {
                if (window.chatWidget) {
                    console.log('üîç Log complet des messages IRC:');
                    window.chatWidget.ircMessageLog.forEach((entry, index) => {
                        console.log(`[${index}] ${entry.timestamp} - ${entry.type}: ${entry.rawMessage}`);
                    });
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher seulement les messages IRC d'un type sp√©cifique
            showIRCMessagesByType: function(type) {
                if (window.chatWidget) {
                    console.log(`üîç Messages IRC de type "${type}":`);
                    const filtered = window.chatWidget.ircMessageLog.filter(entry => entry.type === type);
                    filtered.forEach((entry, index) => {
                        console.log(`[${index}] ${entry.timestamp}: ${entry.rawMessage}`);
                    });
                    console.log(`Total: ${filtered.length} messages de type "${type}"`);
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Activer/D√©sactiver le mode debug
            toggleDebugMode: function() {
                if (window.chatWidget) {
                    window.chatWidget.debugMode = !window.chatWidget.debugMode;
                    console.log(`üîç Mode debug IRC: ${window.chatWidget.debugMode ? 'ACTIV√â' : 'D√âSACTIV√â'}`);
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            }
        };

        console.log('üß™ Fonctions de test disponibles via window.testMessageDeletion');

        // D√©marrer le test automatique apr√®s initialisation du widget
        setTimeout(() => {
            console.log('üöÄ D√©marrage des tests automatiques de chat partag√© (toutes les 20 secondes)');
            // Premier test imm√©diat
            testSharedChatMessage();
            // Puis r√©p√©ter toutes les 20 secondes
            setInterval(testSharedChatMessage, 20000);
        }, 3000); // Attendre 3 secondes pour que le widget soit initialis√©
        // ===== FIN DE LA SECTION DE TEST ===== */

        // Test functions for message deletion (accessible via console)
        window.testMessageDeletion = {
            // Test removing messages by username
            removeByUsername: (username) => {
                if (window.chatWidget) {
                    window.chatWidget.removeMessagesByUsername(username);
                    console.log(`üß™ Test: Suppression des messages de ${username}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

                        // Test removing specific message by ID
            removeById: (messageId) => {
                if (window.chatWidget) {
                    const removed = window.chatWidget.removeMessageById(messageId);
                    console.log(`üß™ Test: Suppression du message ${messageId}: ${removed ? 'succ√®s' : '√©chec'}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

            // List all stored messages
            listMessages: () => {
                if (window.chatWidget) {
                    console.log('üìã Messages stock√©s:', Array.from(window.chatWidget.messages.entries()));
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

            // Test removing messages by content similarity
            removeByContent: (username, content) => {
                if (window.chatWidget) {
                    const removed = window.chatWidget.removeMessageByContent(username, content);
                    console.log(`üß™ Test: Suppression par contenu de ${username}: ${removed ? 'succ√®s' : '√©chec'}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            }
        };

        console.log('üß™ Fonctions de test disponibles via window.testMessageDeletion');
    </script>
</body>
</html>
